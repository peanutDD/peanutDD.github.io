<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="http/https,retrofit2,OkHttp3,Socket,TCP/IP,UDP," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="TCP/IP协议分层 发送协议的主机从上自下将数据按照协议封装，而接收数据的主机则按照协议从得到的数据包解开，最后拿到需要的数据。这种结构和栈很相似，所以把TCP/IP协议族也称为TCP/IP协议栈。  TCP/IP协议栈主要分为四层:应用层、传输层、网络层、数据链路层,每层都有相应的协议。   协议就是双方进行数据传输的一种格式。  应用层：HTTP，FTP等常见协议； 传输层：TCP、UDP；">
<meta name="keywords" content="http&#x2F;https,retrofit2,OkHttp3,Socket,TCP&#x2F;IP,UDP">
<meta property="og:type" content="article">
<meta property="og:title" content="网络请求">
<meta property="og:url" content="http://yoursite.com/2016/08/21/网络请求/index.html">
<meta property="og:site_name" content="鱼人孑">
<meta property="og:description" content="TCP/IP协议分层 发送协议的主机从上自下将数据按照协议封装，而接收数据的主机则按照协议从得到的数据包解开，最后拿到需要的数据。这种结构和栈很相似，所以把TCP/IP协议族也称为TCP/IP协议栈。  TCP/IP协议栈主要分为四层:应用层、传输层、网络层、数据链路层,每层都有相应的协议。   协议就是双方进行数据传输的一种格式。  应用层：HTTP，FTP等常见协议； 传输层：TCP、UDP；">
<meta property="og:image" content="http://i2.buimg.com/567571/0e6eb0b26951c515.png">
<meta property="og:image" content="http://i4.buimg.com/567571/0d4c229145c13360.png">
<meta property="og:image" content="http://7xrn7f.com1.z0.glb.clouddn.com/16-8-23/86650194.jpg">
<meta property="og:image" content="http://i1.buimg.com/567571/315e7f846f5afbac.png">
<meta property="og:image" content="http://i4.buimg.com/567571/12099c8f90d23fcb.png">
<meta property="og:image" content="http://i4.buimg.com/567571/f1b563d05cba2cf0.png">
<meta property="og:image" content="http://imgchr.com/images/TCP.png">
<meta property="og:image" content="http://i2.buimg.com/4851/6bd29b6a3005cf3a.png">
<meta property="og:image" content="http://imgchr.com/images/TCP-IP73318.png">
<meta property="og:image" content="http://imgchr.com/images/IP.png">
<meta property="og:image" content="http://imgchr.com/images/181f0b.png">
<meta property="og:image" content="http://imgchr.com/images/arp.png">
<meta property="og:image" content="http://imgchr.com/images/ICMP.png">
<meta property="og:image" content="http://imgchr.com/images/6a6d58646f6af49d.png">
<meta property="og:image" content="http://imgchr.com/images/IGMP2.png">
<meta property="og:image" content="http://imgchr.com/images/igmp.png">
<meta property="og:updated_time" content="2017-05-26T09:25:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络请求">
<meta name="twitter:description" content="TCP/IP协议分层 发送协议的主机从上自下将数据按照协议封装，而接收数据的主机则按照协议从得到的数据包解开，最后拿到需要的数据。这种结构和栈很相似，所以把TCP/IP协议族也称为TCP/IP协议栈。  TCP/IP协议栈主要分为四层:应用层、传输层、网络层、数据链路层,每层都有相应的协议。   协议就是双方进行数据传输的一种格式。  应用层：HTTP，FTP等常见协议； 传输层：TCP、UDP；">
<meta name="twitter:image" content="http://i2.buimg.com/567571/0e6eb0b26951c515.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/08/21/网络请求/"/>





  <title>网络请求 | 鱼人孑</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  

  <div class="container  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">鱼人孑</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/21/网络请求/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="peanut">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo-1-2.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鱼人孑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">网络请求</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-21T11:29:38+08:00">
                2016-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络请求及框架/" itemprop="url" rel="index">
                    <span itemprop="name">网络请求及框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="TCP-IP协议分层"><a href="#TCP-IP协议分层" class="headerlink" title="TCP/IP协议分层"></a><strong><font color="#FF7256">TCP/IP协议分层</font></strong></h3><blockquote>
<p>发送协议的主机从上自下将数据按照协议封装，而接收数据的主机则按照协议从得到的数据包解开，最后拿到需要的数据。这种结构和栈很相似，所以把TCP/IP协议族也称为TCP/IP协议栈。</p>
</blockquote>
<p><strong><font color="#FF7256">TCP/IP协议栈</font></strong>主要分为四层:<strong>应用层、传输层、网络层、数据链路层,</strong>每层都有相应的协议。<br><img src="http://i2.buimg.com/567571/0e6eb0b26951c515.png" alt=""></p>
<blockquote>
<p><strong><font color="#FF7256"> 协议就是双方进行数据传输的一种格式。</font></strong></p>
</blockquote>
<p><strong><font color="#FF7256">应用层：</font></strong>HTTP，FTP等常见协议；</p>
<p><strong><font color="#FF7256">传输层：</font></strong>TCP、UDP；</p>
<p><strong><font color="#FF7256">网络层：</font></strong>IP协议驻扎层，它负责对数据加上IP地址和其他的数据以确定传输的目标；</p>
<p><strong><font color="#FF7256">链路层：</font></strong>这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。</p>
<p>不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。</p>
<p>其实在链路层之下还有物理层，指的是电信号的传递方式，比如现在以太网通用的网线（双绞线）、早期以太网采用的的同轴电缆（现在主要用于有线电视）、光纤等都属于物理层的概念</p>
<blockquote>
<p><strong>注：如果继续往下便是硬件层次，负责网络的传输，这个层次的定义包括网线的制式，网卡的定义等等，有些书并不把这个层次放在tcp/ip协议族里面，因为它几乎和tcp/ip协议的编写者没有任何的关系。</strong></p>
</blockquote>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a><strong><font color="#FF7256">IP地址</font></strong></h4><p>网络上每一个节点都必须有一个独立的Internet地址（IP地址）。现在通常使用的IP地址是一个32bit的数字（常说的IPv4标准），这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址，具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。</p>
<h4 id="RFC"><a href="#RFC" class="headerlink" title=" RFC"></a><strong><font color="#FF7256"> RFC</font></strong></h4><p><a href="http://www.ietf.org/rfc.html" target="_blank" rel="external"><strong>RFC</strong></a>是tcp/ip协议的标准文档，现在它一共有4000多个协议的定义，我们只需掌握十几个协议。 </p>
<h4 id="端口号-port"><a href="#端口号-port" class="headerlink" title=" 端口号(port)"></a><strong><font color="#FF7256"> 端口号(port)</font></strong></h4><p>这里的端口号是用在TCP、UDP上的一个逻辑号码，并不是一个硬件端口，我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。通过不同的逻辑端口来区分不同的服务。比如用于浏览网页服务（HTTP）的80端口，用于FTP服务的21端口，TeInet 远程登陆 23 端口 ， SMTP 邮件传输协议 25 端口 ，POP3 邮局协议的 110 端口  ，DNS 域名解析的 53号以及 SNMP 的网络管理等等端口 。一个IP地址的端口通过16bit进行编号，最多可以有65536个端口。端口是通过端口号来标记的，端口号只有整数，范围是从0 到65535。</p>
<h5 id="推荐协议"><a href="#推荐协议" class="headerlink" title=" 推荐协议"></a><strong><font color="#FF7256"> 推荐协议</font></strong></h5><p>每一个应用层(TCP/IP参考模型 的最高层) 一般都会使用到两个传输层协议之一: 面向连接的TCP传输控制协议和无连接的包传输的UDP用户数据报文协议 。 其它的一些推荐协议有:</p>
<p>• TELNET (Teletype over the Network, 网络电传) ，通过一个终端(terminal)登陆到网络(运行在TCP协议上)。<br>• FTP (File Transfer Protocol, 文件传输协议) ，由名知义(运行在TCP协议上) 。<br>• SMTP (Simple Mail Transfer Protocol，简单邮件传输协议) ，用来发送电子邮件(运行在TCP协议上) 。<br>• DNS (Domain Name Service，域名服务) ，用于完成地址查找，邮件转发等工作(运行在TCP和UDP协议上) 。<br>• ECHO (Echo Protocol, 回绕协议) ，用于查错及测量应答时间(运行在TCP和UDP协议上) 。<br>• NTP (Network Time Protocol，网络时间协议) ，用于网络同步(运行在UDP协议上) 。<br>• SNMP (Simple Network Management Protocol, 简单网络管理协议) ，用于网络信息的收集和网络管理。<br>• BOOTP (Boot Protocol，启动协议) ，应用于无盘设备(运行在UDP协议上)。</p>
<h5 id="可选协议"><a href="#可选协议" class="headerlink" title=" 可选协议"></a><strong><font color="#FF7256"> 可选协议</font></strong></h5><p>最常用的一些有：</p>
<p>• 支撑万维网WWW的超文本传输协议HTTP；</p>
<p>• 动态配置IP地址的DHCP(Dynamic Host Configuration Protocol,动态主机配置协议)；</p>
<p>• 收邮件用的POP3 (Post Office Protocol, version 3, 邮局协议) ；</p>
<p>• 用于加密安全登陆用的SSH (Secure Shell，用于替代安全性差的TELNET) ；</p>
<p>• 用于动态解析以太网硬件地址的ARP (Address Resolution Protocol，地址解析协议) ；<br> 范例: 不同计算机运行的不同协议</p>
<p>• 一个简单的路由器上可能会实现ARP, IP, ICMP, UDP, SNMP, RIP；</p>
<p>• WWW用户端使用ARP, IP, ICMP, UDP, TCP, DNS, HTTP, FTP；</p>
<p>• 一台用户电脑上还会运行如TELNET, SMTP, POP3, SNMP, ECHO, DHCP, SSH, NTP；</p>
<p>• 无盘设备可能会在固件比如ROM中实现了ARP, IP, ICMP, UDP, BOOT, TFTP (均为面向数据报的协议，实现起来相对简单)。</p>
<h5 id="端口号分类"><a href="#端口号分类" class="headerlink" title=" 端口号分类"></a><strong><font color="#FF7256"> 端口号分类</font></strong></h5><h6 id="逻辑端口"><a href="#逻辑端口" class="headerlink" title=" 逻辑端口"></a><strong><font color="#FF7256"> 逻辑端口</font></strong></h6><p>逻辑意义上的端口有多种分类标准，下面将介绍常见的按端口号分布的分类：</p>
<p>（1）公认端口（Well-Known Ports）</p>
<p>知名端口即众所周知的端口号，范围从0到1023，这些端口号一般固定分配给一些服务。比如21端口分配给FTP(文件传输协议)服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务，135端口分配给RPC（远程过程调用）服务等等。</p>
<p>网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏上指定端口号，方法是在地址后面加上冒号”:”半角），再加上端口 号。比如使用“8080”作为WWW服务的端口，则需要在地址栏里输入“：8080”。</p>
<p>但是，有些系统协议使用固定的端口号，它是不能被改变的，比如139 端口专门用于NetBIOS与TCP/IP之间的通信，不能手动改变。</p>
<p>（2） 注册端口（Registered Ports）</p>
<p>端口号从1025到49151。它们松散地绑定于一些服务。也是说有许多服务绑定于这些端口，这些端口同样用于许多其他目的。这些端口多数没有明确的定义服务对象，不同程序可根据实际需要自己定义，如后面要介绍的远程控制软件和木马程序中都会有这些端口的定义的。记住这些常见的程序端口在木马程序的防护和查杀上是非常有必要的。常见木马所使用的端口在后面将有详细的列表。</p>
<h6 id="动态端口"><a href="#动态端口" class="headerlink" title=" 动态端口"></a><strong><font color="#FF7256"> 动态端口</font></strong></h6><p> 动态和/或私有端口（Dynamic and/or Private Ports）</p>
<p>动态端口的范围从1024到65535，这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。比如1024端口就是分配给第一个向系统发出申请的程序。在关闭程序进程后，就会释放所占用的端口号。</p>
<p>不过，动态端口也常常被病毒木马程序所利用，如冰河默认连接端口是7626、WAY 2.4是8011、Netspy 3.0是7306、YAI病毒是1024等 。</p>
<h6 id="保留端口"><a href="#保留端口" class="headerlink" title=" 保留端口"></a><strong><font color="#FF7256"> 保留端口</font></strong></h6><p>Unix系统有保留端口号的概念。只有具有超级用户特权的进程才允许给它自己分配一个保留端口号。</p>
<p>这些端口号介于1～1023之间，一些应用程序（如有名的Rlogin）将它作为客户与服务器之间身份认证的一部分。</p>
<h5 id="查看端口方式"><a href="#查看端口方式" class="headerlink" title=" 查看端口方式"></a><strong><font color="#FF7256"> 查看端口方式</font></strong></h5><p>（1）利用系统内置的命令，可以在命令提示符下使用“netstat ”查 看系统端口状态，可以列出系统正在开放的端口号及其状态；</p>
<p>（2）利用第三方端口扫描软件；</p>
<p>（3）利用“netstat -n”命令，以数字格式显示地址和端口信息。</p>
<h5 id="65535个端口号使用规则"><a href="#65535个端口号使用规则" class="headerlink" title=" 65535个端口号使用规则"></a><strong><font color="#FF7256"> 65535个端口号使用规则</font></strong></h5><p>（1）端口号小于256的定义为常用端口，服务器一般都是通过常用端口号来识别的。任何TCP/IP实现所提供的服务都用1—1023之间的端口号，是由ICANN来管理的；</p>
<p>（2）客户端只需保证该端口号在本机上是惟一的就可以了。客户端口号因存在时间很短暂又称临时端口号；</p>
<p>（3）大多数TCP/IP实现给临时端口号分配1024—5000之间的端口号。大于5000的端口号是为其他服务器预留的。</p>
<h4 id="应用编程接口"><a href="#应用编程接口" class="headerlink" title=" 应用编程接口"></a><strong><font color="#FF7256"> 应用编程接口</font></strong></h4><p>现在常用的编程接口有socket、FTP、HTTP、telnet以及TLI,而Socket有时候也叫做“Berkeley socket”。</p>
<p>常用的socket类型有两种：</p>
<p>a. 流式socket(SOCK_STREAM) ：是一种面向连接的socket，针对于面向连接的TCP服务应用。<br>b. 数据报式socket(SOCK_DGRAM) ：是一种无连接的socket，对应于无连接的UDP服务应用。 </p>
<p>从用户接口意义上讲，还有传输层的TLI接口，是由AT&amp;T开发的，有时也称作XTI。它是传输层为用户提供的应用程序接口，可以用来在传输层进行应用开发。</p>
<h5 id="四类接口"><a href="#四类接口" class="headerlink" title="四类接口"></a>四类接口</h5><h6 id="1-文件类接口"><a href="#1-文件类接口" class="headerlink" title="1.文件类接口"></a>1.文件类接口</h6><p>FTP协议就是文件类接口，基于FTP，用户可以实现文件在网络间的共享和传输；</p>
<h6 id="2-远程过程调用（RPC-Remote-Procedure-Call-Protocol）"><a href="#2-远程过程调用（RPC-Remote-Procedure-Call-Protocol）" class="headerlink" title="2.远程过程调用（RPC: Remote Procedure Call Protocol）"></a>2.远程过程调用（RPC: Remote Procedure Call Protocol）</h6><p>是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易；</p>
<h6 id="3-数据查询接口"><a href="#3-数据查询接口" class="headerlink" title="3.数据查询接口"></a>3.数据查询接口</h6><p>(后补)</p>
<h6 id="4-数据通信类接口"><a href="#4-数据通信类接口" class="headerlink" title="4.数据通信类接口"></a>4.数据通信类接口</h6><p>socket和HTTP可归结为数据通信接口，基于这两种接口用户可以开发网络通信应用程序，以及web页面交互程序。当然如果从编程开发角度看，无论是FTP、HTTP还是telnet，都是基于socket接口开发出来的应用层协议，是对socket接口的进一步封装和抽象，从而为用户提供更高一层的服务和接口。</p>
<p><strong><font color="#FF7256">域名系统:</font></strong></p>
<p>域名系统是一个分布的数据库，它提供将主机名（就是网址）转换成IP地址的服务。DNS （Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。用户通常通过主机名或域名来访问对方的计算机，计算机则通过IP地址查询服务器。所以DNS就提供了域名查找IP 地址和从IP地址反查域名的服务。</p>
<hr>
<h3 id="一、TCP"><a href="#一、TCP" class="headerlink" title="一、TCP"></a><strong><font color="#FF7256">一、TCP</font></strong></h3><blockquote>
<p><strong><font color="#FF7256">TCP（Transmission Control Protocol）: 传输控制协议</font></strong></p>
</blockquote>
<p> <strong><font color="#FF7256">TCP</font></strong>是面向连接的, 可靠的流协议,保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达)的传输层协议。</p>
<p> TCP位于传输层，提供可靠的字节流服务。字节流服务是指将大块数据分割成报文段（segment）为单位的数据包进行管理，为了保证准确性，TCP 协议采用了三次握手（three-way handshaking）策略。握手过程中使用了 TCP 的标志（flag）—— SYN（synchronize）、ACK（acknowledgement）和 FIN（finish）。</p>
<h4 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a><strong><font color="#FF7256">TCP报文头</font></strong></h4><p><img src="http://i4.buimg.com/567571/0d4c229145c13360.png" alt="|center|"></p>
<h5 id="1-端口号"><a href="#1-端口号" class="headerlink" title="1.端口号"></a><strong><font color="#FF7256">1.端口号</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">源端口 (Source Port) :  长度为16位，2个字节。</font></strong><br><strong><font color="#FF7256">目的端口 (Destination Port) :  长度为16位，2个字节。</font></strong></p>
</blockquote>
<p>网络实现的是不同主机的进程间通信，在一个操作系统中，有很多进程，当数据到来时要提交给哪个进程进行处理，就需要用到端口号。</p>
<p>在TCP头中，包括源端口号(Source Port)和目标端口号(Destination Port)。源端口号标识了发送主机的进程,目标端口号标识接受方主机的进程。</p>
<p>而且，IP实现了点到点的数据通信，而TCP实现的是端到端的通信。通信端用一个IP与端口号来唯一标识。IP协议负责将数据传输到目标主机，而TCP可以根据数据报中的端口号，将数据交给相应的程序进行处理。</p>
<h5 id="2-序列号"><a href="#2-序列号" class="headerlink" title="2.序列号"></a><strong><font color="#FF7256">2.序列号</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">发送序列号 (Sequence Number) :  长度为32位，4个字节。</font></strong></p>
</blockquote>
<p>TCP会话的每一端都包含一个32位（bit）的序列号，该序列号被用来跟踪该端发送的数据量。每一个包中都包含序列号，在接收端则通过确认号用来通知发送端数据成功接收。</p>
<p><strong><font color="#FF7256">发送序号：</font></strong></p>
<p>用来标识从 TCP源端向 TCP目的端发送的数据字节流，它表示在一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从A到B），后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025～2048字节，那么该报文段的序号值就是ISN+1025。另外一个传输方向（从B到A）的TCP报文段的序号值也具有相同的含义。</p>
<blockquote>
<p><strong><font color="#FF7256">确认端口号 (Acknowledgment Number) :  长度为32位，4个字节。</font></strong></p>
</blockquote>
<p><strong><font color="#FF7256">确认序号：</font></strong></p>
<p>包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1。只有 ACK标志为 1时确认序号字段才有效。</p>
<p>假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。 </p>
<p>TCP为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。</p>
<h5 id="3-偏移-首部长度-Offset"><a href="#3-偏移-首部长度-Offset" class="headerlink" title="3.偏移 (首部长度 Offset)"></a><strong><font color="#FF7256">3.偏移 (首部长度 Offset)</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">该字段占用4位，用来表示报文首部的长度，单位是4Byte。如：headLen = ((packet[12]&gt;&gt;4)&amp;0x0F)*4;</font></strong></p>
</blockquote>
<p>这里的偏移实际指的是TCP首部的长度，它用来表明TCP首部中32 bit字的数目，通过它可以知道一个TCP包它的用户数据是从哪里开始的。这个字段占4bit,如4bit的值是0101,则说明TCP首部长度是5 <em> 4 = 20字节。 所以TCP的首部长度最大为15 </em> 4 = 60字节。然而没有可选字段，正常长度为20字节。</p>
<h5 id="4-预留6位-Reserved"><a href="#4-预留6位-Reserved" class="headerlink" title="4.预留6位 (Reserved)"></a><strong><font color="#FF7256">4.预留6位 (Reserved)</font></strong></h5><p>长度为6位，作为保留字段，暂时没有什么用处。</p>
<h5 id="5-TCP-Flags"><a href="#5-TCP-Flags" class="headerlink" title="5.TCP Flags"></a><strong><font color="#FF7256">5.TCP Flags</font></strong></h5><blockquote>
<p><strong>标志(6bit):在TCP首部中有6个标志比特，他们中的多个可同时被置为1 。</strong></p>
</blockquote>
<p><strong><font color="#FF7256">URG标志：</font></strong></p>
<p>紧急指针(Urgent Pointer)有效，我们称携带ACK标志的TCP报文段为确认报文段；</p>
<p><strong><font color="#FF7256">ACK标志：</font></strong></p>
<p>确认序号有效；</p>
<p><strong><font color="#FF7256">PSH标志：</font></strong></p>
<p>指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中）；</p>
<p><strong><font color="#FF7256">RST标志：</font></strong></p>
<p>表示要求对方重新建立连接，我们称携带RST标志的TCP报文段为复位报文段；</p>
<p><strong><font color="#FF7256">SYN标志：</font></strong></p>
<p>同步序号用来发起建立一个连接，我们称携带SYN标志的TCP报文段为同步报文段；</p>
<p><strong><font color="#FF7256">FIN标志：</font></strong></p>
<p>发送端完成发送任务(即断开连接)，我们称携带FIN标志的TCP报文段为结束报文段。</p>
<h5 id="6-窗口大小-window"><a href="#6-窗口大小-window" class="headerlink" title="6.窗口大小 (window)"></a><strong><font color="#FF7256">6.窗口大小 (window)</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">长度为16位，2个字节，表示源方法最多能接受的字节数。</font></strong></p>
</blockquote>
<p>是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</p>
<h5 id="7-校验和-CheckSum"><a href="#7-校验和-CheckSum" class="headerlink" title="7.校验和 (CheckSum)"></a><strong><font color="#FF7256">7.校验和 (CheckSum)</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">长度为16位，2个字节。</font></strong></p>
</blockquote>
<p>由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。<strong><font color="#FF7256">这也是TCP可靠传输的一个重要保障。</font></strong></p>
<p>校验和覆盖了整个的TCP报文段:TCP头部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</p>
<h5 id="8-紧急指针-：-UrgentPointer"><a href="#8-紧急指针-：-UrgentPointer" class="headerlink" title="8.紧急指针 ：(UrgentPointer)"></a><strong><font color="#FF7256">8.紧急指针 ：(UrgentPointer)</font></strong></h5><blockquote>
<p><strong><font color="#FF7256">长度为16位，2个字节。</font></strong></p>
</blockquote>
<p>只有当URG标志置为1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。</p>
<blockquote>
<p><strong>以上8个字段是TCP包头必须要有的字段，也称固有字段，长度为20个字节。</strong></p>
</blockquote>
<h5 id="9-TCP选项-Options"><a href="#9-TCP选项-Options" class="headerlink" title="9.TCP选项 (Options)"></a><strong><font color="#FF7256">9.TCP选项 (Options)</font></strong></h5><p>此项是可选项(可有可无)，抓包时具体分析。</p>
<h4 id="三次握手建立连接-three-way-handshake"><a href="#三次握手建立连接-three-way-handshake" class="headerlink" title="三次握手建立连接 (three-way handshake)"></a><strong><font color="#FF7256">三次握手建立连接 (three-way handshake)</font></strong></h4><p><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-8-23/86650194.jpg" alt=""></p>
<p>第一次握手：客户端发送syn包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认;</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN(ack=x+1)，同时自己也发送一个SYN包(seq=y)，即SYN+ACK包，此时服务器进入SYN_RECV状态;</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p>三次握手确定了双方间包的序号、最大接受数据的大小(window)以及MSS(Maximum Segment Size)。MSS = MTU - IP头 - TCP头(TCP携带可选项,大小为12),MTU表示最大传输单元，我们在IP头分析的时候会讲到,它一般为1500个字节。IP头和TCP 头部带可选选项的时候都是20个字节。这样的话MSS=1500 - 20 -20 = 1460，最大传输数据为：1500 - 20 - ( 20 + 12 ) = 1448。MSS限制了TCP包携带数据的大小,它的意思就是当应用层向传输层提交数据通过TCP协议进行传输时，如果应用层的数据&gt;MSS就必须分段，分成多个段，逐个的发过去。<strong><font color="#FF7256">(可以通过wirshar抓包进行分析)</font></strong></p>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a><strong><font color="#FF7256">数据传输</font></strong></h4><p><img src="http://i1.buimg.com/567571/315e7f846f5afbac.png" alt=""></p>
<p> <strong><font color="#FF7256">TCP采用一种名为“带重传功能的肯定确认（positive acknowledge with retransmission）”的技术作为提供可靠数据传输服务的基础。</font></strong>这项技术要求接收方收到数据之后向源站回送确认信息ACK。发送方对发出的每个分组都保存一份记录，在发送下一个分组之前等待确认信息。发送方还在送出分组的同时启动一个定时器，并在定时器的定时期满而确认信息还没有到达的情况下，重发刚才发出的分组。为了避免由于网络延迟引起迟到的确认和重复的确认，协议规定在确认信息中稍带一个分组的序号，使接收方能正确将分组与确认关联起来。</p>
<p>虽然网络具有同时进行双向通信的能力，但由于在接到前一个分组的确认信息之前必须推迟下一个分组的发送，简单的肯定确认协议浪费了大量宝贵的网络带宽。为此， TCP使用滑动窗口的机制来提高网络吞吐量，同时解决端到端的流量控制。</p>
<h5 id="a-超时重传"><a href="#a-超时重传" class="headerlink" title="a.超时重传"></a>a.超时重传</h5><p><strong><font color="#FF7256">超时重传机制用来保证TCP传输的可靠性。</font></strong>其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。每次发送数据包时，发送的数据报都有seq号，接收端收到数据后，会回复ack进行确认，表示某一seq号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。</p>
<p>对于实现而言，关键之处就在于超时和重传的策略，即怎样决定超时间隔和如何确定重传频率。</p>
<p>TCP管理4种不同的定时器：</p>
<h6 id="重传定时器-Retransmission-Timer-："><a href="#重传定时器-Retransmission-Timer-：" class="headerlink" title="重传定时器(Retransmission Timer)："></a><font color="#FF7256">重传定时器(Retransmission Timer)：</font></h6><p>当希望收到另一端的确认时使用。</p>
<h6 id="坚持定时器-Persistent-Timer-："><a href="#坚持定时器-Persistent-Timer-：" class="headerlink" title="坚持定时器(Persistent Timer)："></a><font color="#FF7256">坚持定时器(Persistent Timer)：</font></h6><p>使窗口信息保持不断流动，即使另一端关闭了其接收窗口。</p>
<p>TCP通过让接收方指明希望从发送方接收的数据字节数（即窗口大小）来进行流量控制。如果窗口大小为0会发生什么情况呢？这将有效阻止发送方传送数据，直到窗口变为非0为止。<br>ACK的传输并不可靠，也就是说，TCP不对ACK报文段进行确认，TCP只确认那些包含有数据的ACK报文段。</p>
<ol>
<li><p>坚持定时器<br>假设一个场景：如果一个确认丢失了，则双方就有可能因为等待对方而使连接终止，接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新。为防止这种死锁情况的发生，发送方使用一个坚持定时器（persist timer）来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查（window probe）。<br>计算坚持定时器时使用了普通的TCP指针退避，窗口探查报文包含一个字节的数据。<br>坚持状态与21章介绍的重传超时之间一个不同的特点就是TCP从不放弃发送窗口探查。这些探查每隔60秒发送一次，这个过程将持续到窗口打开或者应用进程使用的连接被终止。</p>
</li>
<li><p>糊涂窗口综合症<br>糊涂窗口综合症：接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方可以通过这个小窗口发送少量的数据（而不是等待其它的数据以便发送一个大的报文段），即，少量的数据通过连接交换，而不是满长度的报文段，TCP的传输效率可想而知。<br>如何避免“糊涂窗口综合症”：<br>接收方：接收方不通告小窗口，除非增加一个报文段(MMS)或者接收方缓存空间的一半，否则通告为0。</p>
</li>
</ol>
<p>发送方：<br>(1)可以发送一个满长度的报文段(MMS)<br>(2)可以发送至少接收方通告窗口一半的报文段<br>(3)能够发送手头的所有数据并且不希望接收ACK，或者该连接禁止了Nagle算法时，可以发送任意数据。</p>
<p>坚持定时器工作流程:</p>
<p>(1)发送端收到0窗口通告后，就启动坚持定时器，并在定时器溢出的时候向客户端查询窗口是否已经增大。<br>(2)在定时器未到，就收到非零通告，则关闭该定时器，并发送数据。<br>(3)若定时器已到，还没有收到非零通告，就发探查报文。<br>(4)如果探查报文ACK的通告窗口为0，就将坚持定时器的值加倍，TCP的坚持定时器使用1，2，4，8，16……64秒这样的普通指数退避序列来作为每一次的溢出时间，重复1、2、3步，如果通告窗口非零，发送数据，关闭定时器。</p>
<h6 id="保活定时器-Keeplive-Timer-："><a href="#保活定时器-Keeplive-Timer-：" class="headerlink" title="保活定时器(Keeplive Timer)："></a><font color="#FF7256">保活定时器(Keeplive Timer)：</font></h6><p>检测一个空闲连接的另一端何时崩溃或重启。</p>
<p>现实中可能存在这么一种空闲TCP连接：没有任何数据流通过。也就是说，如果TCP连接的双方都没有向对方发送数据，则在两个TCP模块之间不交换任何信息，这意味着我们可以启动一个客户与服务器建立连接，然后长时间不使用，而连接依然保持。中间的路由器可以崩溃和重启，电话线可以被挂断再连接，但只要两端的主机没有被重启，则连接依然保持建立。</p>
<p>然而，许多时候一个服务器希望知道客户主机是否崩溃并关机或者崩溃又重新启动，许多实现提供的保活定时器可以提供这种能力。保活并不是TCP规范中的一部分。</p>
<p>保活定时器工作原理：<br>如果一个给定的连接在2小时内没有任何动作，那么服务器就向客户发送一个探查报文段。客户主机必须处于以下4个状态之一：</p>
<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方的正常工作的，服务器在2小时内将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应，服务器将不能收到对探查的响应，并在75秒后超时，总共发送10个探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。这是服务器将收到一个对其保活探查的响应，但这个响应是一个RST复位，使得服务器终止这个连接。</li>
<li>客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与2之间的区别，它所能发现的就是没有收到探查的响应。</li>
</ol>
<p>服务器不用关注客户主机被关闭和重新启动的情况，当系统被操作员关闭时，所有的应用进程也被终止，这会使客户的TCP在连接上发出一个FIN。接收到FIN将使服务器的TCP向服务器进程报告文件结束，使服务器可以检测到这个情况。</p>
<h6 id="2MSL定时器（Time-Wait-Timer-："><a href="#2MSL定时器（Time-Wait-Timer-：" class="headerlink" title="2MSL定时器（Time_Wait Timer)："></a><font color="#FF7256">2MSL定时器（Time_Wait Timer)：</font></h6><p>测量一个连接处于TIME_WATI状态的时间。</p>
<p>在连接终止期使用，当TCP关闭连接时，并不认为这个连接就真正关闭了，在时间等待期间，连接还处于一种中间过度状态。这样就可以时重复的fin报文段在到达终点后被丢弃，这个计时器的值通常设置为一格报文段寿命期望值的两倍。</p>
<p>补充：</p>
<p>2MSL定时器：MSL是报文段最大生存时间(Maximum Segment Lifetime)，设置这个定时器有两个目的：</p>
<p>其一，是为了测量连接处于TIME_WAIT状态的时间，这样可以让TCP再次发送最后的ACK以防止这个ACK丢失(如果丢失，另一端会重传FIN)。</p>
<p>其二，为允许老的重复分节在网络中消逝。具体可以解释为，如果一个TCP连接在断开之前有迷途分节尚未消逝，在断开该TCP连接之后立刻重启一个同样的连接(双方的IP地址和端口port相同)，这时之前的迷途的老分节可能对新的新的TCP连接接收，从而造成未定义的错误。为了避免这种情况，TCP规定在TIME_WAIT状态，不能启动一个连接的化身。既然TIME_WAIT状态维持2MSL，这就保证了一个连接上的分组及其应该在 2MSL内都会消失。</p>
<h6 id="指数退避："><a href="#指数退避：" class="headerlink" title="指数退避："></a><font color="#FF7256">指数退避：</font></h6><p>书中检查连续重传之间不同的时间差，它们取整后分别是1、3、6、12、24、48和多个64秒，其中第一次发送后设置的超时时间设置为1.5秒。（2的N次方*1.5秒）</p>
<h6 id="1-往返时间测量"><a href="#1-往返时间测量" class="headerlink" title="1.往返时间测量"></a>1.往返时间测量</h6><p>RTT(往返时间)：指发送端发送TCP报文段开始到接收到对方的确定所使用的时间。</p>
<blockquote>
<p>TCP超时与重传中最重要的部分就是对一个给定连接的往返时间的测试。由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。</p>
</blockquote>
<p>RTO(超时重传时间)：发送端发送TCP报文段后，在RTO时间内没有收到对方确定，即重传该报文段。</p>
<p>最早的TCP曾经用了一个非常简单的公式来估计当前网络的状况，如下：</p>
<p>R&lt;-aR+(1-a)M<br>RTP=Rb</p>
<p>其中a是一个经验系数为0.9，称为平滑因子，b通常为2。这个数值是可以被修改的。这个公式是说用旧的RTT(R)和新的RTT(M)综合到一起来考虑新的RTT(R)的大小。每次进行新测量时，这个被平滑的RTT将得到更新。每个新估计的90%来自前一个估计，而10%则取自新的测试。</p>
<p>但是，在RTT变化范围很大时，使用这个方法无法跟上这种变化，从而引起不必要的重传。当网络已经处于饱和状态时，不必要的和重传会增加网络的负载，对网络而言就像在火上浇油。于是就有下面的修正公式：</p>
<p>Err=M-A<br>A&lt;-A+gErr<br>D&lt;-D+h(|Err|-D)<br>RTO=A+4D</p>
<p>A 平滑的RTT(均值估计器)<br>D 平滑的方差<br>g 增量<br>h 方差的增益</p>
<p>RTO值基于RTT的均值和方差，这更好的响应了RTT的变化。</p>
<p>karn算法（重传多义性）</p>
<p>假如发送一个分组，当发生超时，RTO指数退避，重传该分组，然后收到ACK。此时但并不能确定这个ACK是针对第一个分组还是重传分组，这就是重传多义性问题。</p>
<p>karn算法针对这个问题</p>
<p>(1)对于超时重传的数据报的确认，不更新RTT。<br>(2)要注意的是：重传的情况下，RTO不用上面的公式计算，而采用一种叫做“指数退避”的方式。RTO指数退避，下一次传送就使用这个RTO值。<br>(3)重传数据确认之后，再次发送的数据如果正常被确定，恢复Jacobson 1988公式，更新RTO和RTT。</p>
<h6 id="2-拥塞避免算法"><a href="#2-拥塞避免算法" class="headerlink" title="2.拥塞避免算法"></a>2.拥塞避免算法</h6><p>该算法假定由于分组受到损坏引起的丢失是非常少的，因此分组丢失就意味着源主机和目的主机之间的某处网络上发生了拥塞。有两种分组丢失的指示：</p>
<p>a.发生超时</p>
<p>b.接收到重复的确认</p>
<p>数据在传输的时候不能只使用一个窗口协议，我们还需要有一个拥塞窗口来控制数据的流量，使得数据不会一下子都跑到网路中引起“拥塞”。也曾经提到过，拥塞窗口最初使用指数增长的速度来增加自身的窗口，直到发生超时重传，再进行一次微调。但是没有提到，如何进行微调，拥塞避免算法和慢启动门限就是为此而生。</p>
<p>所谓的慢启动门限就是说，当拥塞窗口超过这个门限的时候，就使用拥塞避免算法，而在门限以内就采用慢启动算法。所以这个标准才叫做门限，通常，拥塞窗口记做cwnd，慢启动门限记做ssthresh。下面我们来看看拥塞避免和慢启动是怎么一起工作的。</p>
<p>拥塞避免算法和慢启动算法是两个目的不同、独立的算法。我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点，拥塞避免算法和慢启动算法通常一起使用：</p>
<p>每个连接维持两个变量: 拥塞窗口( cwnd )  、慢启动门限( ssthresh )</p>
<p>算法概要：</p>
<p>a.对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节。</p>
<p>b.TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。</p>
<p>c.当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半[下图中的12]（cwnd 和接收方通告窗口大小的最小值，但最少为2个报文段）。此外，如果是超时引起了拥塞，则 cwnd被设置为1个报文段（这就是慢启动）。</p>
<p>d.当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果cwnd小于或等于ssthresh，则正在进行慢启动，否则正在进行拥塞避免。 慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止（因为我们记录了在步骤2 中给我们制造麻烦的窗口大小的一半），然后转为执行拥塞避免。</p>
<p>cwnd增加方式：</p>
<p>慢启动初始cwnd为1，每收到一个确定就加1，成指数增长。<br>拥塞避免算法在每个RTT内增加 1/cwnd 个报文，成线性增长。<br>慢启动根据收到的ACK次数增加cwnd，而拥塞避免算法在一个RTT不管收有多少ACK也只增加一次。</p>
<h6 id="3-快速重传和快速恢复算法"><a href="#3-快速重传和快速恢复算法" class="headerlink" title="3.快速重传和快速恢复算法"></a>3.快速重传和快速恢复算法</h6><p>如果收到3个重复ACK，可认为该报文段已经丢失，此时无需等待超时定时器溢出，直接重传丢失的包，这就叫快速重传算法。而接下来执行的不是慢启动而是拥塞避免算法，这就叫快速恢复算法。</p>
<p>(1)当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半，重传丢失的报文段，设置cwnd为ssthresh加上3倍的报文段大小。</p>
<p>(2)每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组(如果新的cwnd允许发送)。</p>
<p>(3)当下一个确认新数据的ACK到达时，设置cwnd为ssthresh(在第1步中设置的值)。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。</p>
<h6 id="4-ICMP（Internet-Control-Message-Protocol）Internet控制报文协议）差错"><a href="#4-ICMP（Internet-Control-Message-Protocol）Internet控制报文协议）差错" class="headerlink" title="4.ICMP（Internet Control Message Protocol）Internet控制报文协议）差错"></a>4.ICMP（Internet Control Message Protocol）Internet控制报文协议）差错</h6><p>TCP能够遇到的最常见的ICMP差错就是源站抑制、主机不可达和网络不可达。</p>
<p>(1)源站抑制的ICMP将拥塞窗口cwnd置为1个报文段，并发起慢启动，慢启动门限ssthresh不变，窗口将打开直至开放了所有的通路(受窗口大小和往返时间的限制)或者发生了拥塞。<br>(2)主机不可达或网络不可达的ICMP将被忽略，因为这两上差错都被认为是短暂现象。</p>
<h6 id="5-重新分组"><a href="#5-重新分组" class="headerlink" title="5.重新分组"></a>5.重新分组</h6><p>当TCP超时并重传时，它不一定需要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能（当然，这个较大的报文段不能够超过接收方声明的MSS）</p>
<h5 id="b-快速重传"><a href="#b-快速重传" class="headerlink" title="b.快速重传"></a>b.快速重传</h5><p>接受数据一方发现有数据包丢掉了。就会发送ack报文告诉发送端重传丢失的报文。如果发送端连续收到标号相同的ack包，则会触发客户端的快速重传。比较超时重传和快速重传，可以发现超时重传是发送端在傻等超时，然后触发重传;而快速重传则是接收端主动告诉发送端数据没收到，然后触发发送端重传。</p>
<h5 id="c-流量控制-滑动窗口技术"><a href="#c-流量控制-滑动窗口技术" class="headerlink" title="c.流量控制(滑动窗口技术)"></a>c.流量控制(滑动窗口技术)</h5><p>这里主要说TCP滑动窗流量控制。TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 <strong><font color="#FF7256">滑动窗可以是提高TCP传输效率的一种机制。</font></strong></p>
<p>滑动窗口技术是简单的带重传的肯定确认机制的一个更复杂的变形，它允许发送方在等待一个确认信息之前可以发送多个分组。如下图所示，发送方要发送一个分组序列，滑动窗口协议在分组序列中放置一个固定长度的窗口，然后将窗口内的所有分组都发送出去；当发送方收到对窗口内第一个分组的确认信息时，它可以向后滑动并发送下一个分组；随着确认的不断到达，窗口也在不断的向后滑动。</p>
<p><img src="http://i4.buimg.com/567571/12099c8f90d23fcb.png" alt="|center|"></p>
<h5 id="d-拥塞控制"><a href="#d-拥塞控制" class="headerlink" title="d.拥塞控制"></a>d.拥塞控制</h5><p>滑动窗用来做流量控制。流量控制只关注发送端和接受端自身的状况，而没有考虑整个网络的通信情况。拥塞控制，则是基于整个网络来考虑的。考虑一下这样的场景：某一时刻网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。为此，TCP引入了拥塞控制策略。拥塞策略算法主要包括：慢启动，拥塞避免，拥塞发生，快速恢复。</p>
<h4 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a><strong><font color="#FF7256">四次挥手断开连接</font></strong></h4><p><img src="http://i4.buimg.com/567571/f1b563d05cba2cf0.png" alt=""></p>
<p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但此时主动关闭方还可以接受数据；</p>
<p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)；</p>
<p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了；</p>
<p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
<hr>
<p>CLOSED： 表示初始状态；</p>
<p>LISTEN：表示服务器端的某个SOCKET处于监听状态，可以接受连接了；</p>
<p>SYN_RCVD： 表示接收到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态；</p>
<p>SYN_SENT：与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文；</p>
<p>ESTABLISHED：表示连接已经建立了；</p>
<p>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到；</p>
<p>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接；</p>
<p>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态；</p>
<p>CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接；</p>
<p>CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接；</p>
<p>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</p>
<ol>
<li>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</li>
</ol>
<p>因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<ol>
<li>为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</li>
</ol>
<p>因为，虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p>
<hr>
<p>最后附上TCP的状态图</p>
<p><img src="http://imgchr.com/images/TCP.png" alt=""></p>
<h3 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a><strong><font color="#FF7256">二、UDP</font></strong></h3><p>UDP协议也是传输层协议，它是无连接，不保证可靠的传输层协议。</p>
<p><img src="http://i2.buimg.com/4851/6bd29b6a3005cf3a.png" alt=""></p>
<p> UDP是传输层协议，和TCP协议处于一个分层中，但是与TCP协议不同，UDP协议并不提供超时重传，出错重传等功能，也就是说其是不可靠的协议。</p>
<p> UDP协议是英文UserDatagramProtocol的缩写，即用户数据报协议，主要用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的C/S模式的网络应用都需要使用UDP协议。UDP协议直接位于IP（网际协议）协议的顶层。</p>
<p><strong><font color="#FF7256">特点：</font></strong> </p>
<ol>
<li>无连接，发送数据之前不需要建立连接。开销和发送之前的时间延迟较短。 </li>
<li>尽最大努力交付。（可以采取一定策略实现可靠传输）</li>
<li>面向报文，UDP对应用程序交付的报文，添加UDP首部后直接交给IP层。不合并，不拆分。</li>
<li>没有拥塞控制，网络拥塞不会使源主机发送率降低。</li>
<li>UDP支持一对一，一对多，多对一的交互通信</li>
<li>UDP首部开销较小，8字节（TCP为20字节、IP为20字节）</li>
</ol>
<p>UDP首部格式</p>
<blockquote>
<p>源端口：2字节 =   16bit =0 ~ 65535 ( 注：端口与TCP端口意义一样 )<br>   目的端口：2字节</p>
</blockquote>
<p>由于很多软件需要用到UDP协议，所以UDP协议必须通过某个标志用以区分不同的程序所需要的数据包。端口号的功能就在于此，例如某一个UDP程序A在系统中注册了3000端口，那么，以后从外面传进来的目的端口号为3000的UDP包都会交给该程序。端口号理论上可以有2^16这么多。因为它的长度是16个bit。</p>
<blockquote>
<p>长度(Length)：2字节  标识UDP头的长度(用户数据包的长度)（最短为8字节，仅有头部）</p>
</blockquote>
<p>UDP可以很长很长，可以有65535字节那么长。但是一般网络在传送的时候，一次一般传送不了那么长的协议（涉及到MTU的问题），就只好对数据分片，当然，这些是对UDP等上级协议透明的，UDP不需要关心IP协议层对数据如何分片。</p>
<blockquote>
<p>检验和(Checksum)：2字节</p>
</blockquote>
<p>这是一个可选的选项，并不是所有的系统都对UDP数据包加以检验和数据(相对TCP协议的必须来说)，但是RFC中标准要求，发送端应该计算检验和。</p>
<p>UDP检验和覆盖UDP协议头和数据，这和IP的检验和是不同的，IP协议的检验和只是覆盖IP数据头，并不覆盖所有的数据。UDP和TCP都包含一个伪首部，这是为了计算检验和而摄制的。伪首部甚至还包含IP地址这样的IP协议里面都有的信息，目的是让UDP两次检查数据是否已经正确到达目的地。如果发送端没有打开检验和选项，而接收端计算检验和有差错，那么UDP数据将会被悄悄的丢掉（不保证送达），而不产生任何差错报文。</p>
<p><strong><font color="#FF7256">UDP和ARP之间的交互式用</font></strong></p>
<p>这是不常被人注意到的一个细节，这是针对一些系统地实现来说的。当ARP缓存还是空的时候。UDP在被发送之前一定要发送一个ARP请求来获得目的主机的MAC地址，如果这个UDP的数据包足够大，大到IP层一定要对其进行分片的时候，想象中，该UDP数据包的第一个分片会发出一个ARP查询请求，所有的分片都辉等到这个查询完成以后再发送。事实上是这样吗？</p>
<p>结果是，某些系统会让每一个分片都发送一个ARP查询，所有的分片都在等待，但是接受到第一个回应的时候，主机却只发送了最后一个数据片而抛弃了其他，这实在是让人匪夷所思。这样，因为分片的数据不能被及时组装，接受主机将会在一段时间内将永远无法组装的IP数据包抛弃，并且发送组装超时的ICMP报文（其实很多系统不产生这个差错），以保证接受主机自己的接收端缓存不被那些永远得不到组装的分片充满。</p>
<p><strong><font color="#FF7256">应用方向：</font></strong></p>
<p>包总量较少的通信(DNS, SNMP等)；<br>视频,音频等多媒体通信(即时通信)；<br>限定于LAN等特定网络中的应用通信；<br>广播通信(广播, 多播)</p>
<h3 id="三、IP协议"><a href="#三、IP协议" class="headerlink" title="三、IP协议"></a><strong><font color="#FF7256">三、IP协议</font></strong></h3><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，ICMP，IGCP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议TCP或UDP要做的事情。所以这也就出现了TCP是一个可靠的协议，而UDP就没有那么可靠的区别。</p>
<p>IP（Internet Protocol）网际协议位于网络层。其作用是把各种数据包传送给对方，需要满足各类条件，最重要的两个条件便是 IP 地址 和 MAC 地址。IP 地址可以和 MAC 地址进行配对，IP 地址可变换，但 MAC 地址基本不会更改。</p>
<p>在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP （Address Resolution Protocol）协议。 ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p>
<p><strong><font color="#FF7256">特点：</font></strong> </p>
<ol>
<li><p>不可靠性（unreliable）是它不能保证 I P数据报能成功地到达目的地。 I P仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区， I P有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP） 。</p>
</li>
<li><p>无连接性（connectless）的意思是I P并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明， I P数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是B） ，每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。</p>
</li>
</ol>
<p>它提供不可靠、无连接的服务，也即依赖其他层的协议进行差错控制。在局域网环境，IP协议往往被封装在以太网帧中传送。而所有的TCP、UDP、ICMP、IGMP数据都被封装在IP数据报中传送。如图下图所示：</p>
<p><img src="http://imgchr.com/images/TCP-IP73318.png" alt="TCP/IP报文封装"></p>
<h5 id="IP报文头格式"><a href="#IP报文头格式" class="headerlink" title="IP报文头格式"></a><strong><font color="#FF7256">IP报文头格式</font></strong></h5><p><img src="http://imgchr.com/images/IP.png" alt="IP协议头"></p>
<p>　　●版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。</p>
<p>　　●报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。<br>　<br>　　●服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。实际上，大部分主机会忽略这个字段，但一些动态路由协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。</p>
<p>　　●总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。</p>
<p>　　●标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。</p>
<p>　　●标志位字段(Flag)：占3比特。标志一份数据报是否要求分段。</p>
<p>　　●段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。</p>
<p>　　●生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。</p>
<p>　　●协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。</p>
<p>　　●头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。</p>
<p>　　●源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。</p>
<p>　　●可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。</p>
<h5 id="IP路由选择"><a href="#IP路由选择" class="headerlink" title="IP路由选择"></a><strong><font color="#FF7256">IP路由选择</font></strong></h5><p>如果目的主机与源主机直接相连或都在一个共享网络上,那就直接把包发送到目的主机,<br>如果不是,那把IP数据报送到默认路由器,由它转发。路由器使用路由表保存自己知道的网络的信息,它包括:</p>
<p>目的IP地址：它可以是一个完整的主机地址或是一个网络地址,主机地址主机号非0,网络地址主机号为0。</p>
<p>下一个路由器地址：这个路由器是与当前路由器直接相连的路由器,或是直接相连的网络ip地址(考虑到一台电脑有两个网口,其中一个连接目的地址)标志，其中一个表明目的IP地址是网络地址还是主机地址。另一个指明下一站是真正的路由器还是网络接口为数据报的传输指定一个网络接口。</p>
<p>每个路由器都不需要知道所有网络的信息,当它发现要转发的包不在与自己直接连接的网络时,就会把这个包发给下一个路由器,一直到终点。</p>
<p>IP路由选择主要完成以下功能：</p>
<p>1 搜索路由表,寻找能与目的地址完全匹配的条目,如果找到直接发给它；<br>2 搜索路由表,寻找能与目的网络号完全匹配的条目,如果找到将包发给这一条目指定的下一个路由器或是网络接口；<br>3 搜索路由表,寻找默认条目,如果找到把这个报文发给它。如果都不成功,将不再发送这个包,向源地址发送一个ICMP不可达报文，使用网络号而不是具体主机可以减少路由表的大小。</p>
<h5 id="子网编码"><a href="#子网编码" class="headerlink" title=" 子网编码"></a><strong><font color="#FF7256"> 子网编码</font></strong></h5><ol>
<li>子网寻址：</li>
</ol>
<p>IP地址分成A类,B类,C类这三种,但是A和B又太大了 而现在IP地址不够用,所以需要使用子网寻址的办法将IP地址进行进一步划分,将主机号再分成子网号与主机号，如A类的网络地址为255.0.0.0，某个A类地址为11.22.33.44，这时第一个数(11)就是网络号，后面三个数(22.33.44)就是主机号。使用子网寻址技术就是把后面三个(22.33.44)再划分成子网与主机号,如把第二与第三个数字看成是子网号(22.33),最后一位是主机号(44)，这样增加了可用的IP地址数目，另外这一过程对路由器不透明,所以路由器知道怎样把一个包正确的发到对应的子网中去。</p>
<ol>
<li>子网掩码：</li>
</ol>
<p>由于使用了子网寻址,所以不可以直接使用A类的网络地址与主机地址来判断一台主机是不是在同一网络上,这时需要使用子网掩码来进行区分子网号与主机号,有了它,主机可以确定IP数据报的目的是：</p>
<ol>
<li>本子网中主机,，</li>
<li>本网络中其它子网主机，</li>
<li>其它网络主机</li>
</ol>
<p>如下：</p>
<p>IP地址:11.33.44.55，子网掩码为255.255.255.0(在校园网的设定中)，子网掩码是由32bit的二进制数字序列,形式为是一连串的1和一连串的0，IP地址的定义是网络号+主机号。但是现在所有的主机都要求子网编址，也就是说，把主机号在细分成子网号+主机号。最终一个IP地址就成为 网络号码+子网号+主机号。例如一个B类地址：210.30.109.134。例如：255.255.255.0(二进制就是11111111.11111111.11111111.00000000)对于刚才的那个B类地址，因为210.30是网络号，那么后面的109.134就是子网号和主机号的组合，又因为子网掩码只有后八bit为0，所以主机号就是IP地址的后八个bit，就是134，而剩下的就是子网号码-109。，因为它是11，所以是一个A类网络，从掩码中可以知道它所在子网为33.44，主机号为55，如果它要发一个ip包给11.33.44.66,那从子网掩码中可以知道目标主机与源主机在同一子网上，可以直接发送。如果要发给11.22.33.44 那从子网掩码知道目标是在同一网络中不在同一子网中，到12.33.44.55那从A类地址的掩码就可以直接判断不是同一网络内了。</p>
<h5 id="特殊的IP"><a href="#特殊的IP" class="headerlink" title=" 特殊的IP"></a><strong><font color="#FF7256"> 特殊的IP</font></strong></h5><p>在电脑设置中,常用到127.0.0.1,这是一个回环地址,发给它的包会返回给自己,那还有没有其它的特殊IP呢</p>
<ol>
<li>网络号与主机号都是0；</li>
<li>网络号是0,主机号不是0；</li>
</ol>
<p>上面两个出现在自己的IP地址还不知道的条件下,如使用BOOTP协议进行启动,只能用于初始化过程。</p>
<ol>
<li>127.x.x.x,回环地址,注意后面三个数都是任意的,我们常用127.0.0.1并不表示127.88.99.110不是回环地址；</li>
<li>网络号与主机号都是255,也就是255.255.255.255,这个是受限广播,表示向当前子网广播,只可作为目的而不可作为源地址；</li>
<li>主机号为255,这表示向某个子网广播；</li>
<li>子网和主机号都为255,表示向所有子网,及每个子网下所有主机都进行广播。</li>
</ol>
<p>注：0可以看成是本,如主机号为0表示本主机,网络号为0表示本网络</p>
<p>总结:</p>
<ol>
<li>IP协议的特点是:不可靠,无连接</li>
<li>IP包格式,注意在包格式中有标志位,说明包内数据的类型</li>
<li>路由方式,就是如果是直连就直接发送,如果不直连,查找到目的网络的通路并转发,如果没有找到到对方网络的通路,则转给默认路由器,如果没有指定默认路由,那返回一个ICMP错误</li>
<li>子网编码,它的出现是为了提高ip地址利用率,是把ABC类IP地址的主机部分分成子网与主机部分<br>另外对应子网编码的是子网掩码,帮助主机判断目标地址的位置信息</li>
<li>特殊的IP,主要有广播IP,全0IP与回环地址</li>
</ol>
<h5 id="分片解释"><a href="#分片解释" class="headerlink" title="分片解释"></a><strong><font color="#FF7256">分片解释</font></strong></h5><p>以太网的MTU是1500，你可以用 netstat -i 命令查看这个值。如果IP层有数据包要传，而且数据包的长度超过了MTU，那么IP层就要对数据包进行分片（fragmentation）操作，使每一片的长度都小于或等于MTU。我们假设要传输一个UDP数据包，以太网的MTU为1500字节，一般IP首部为20字节，UDP首部为8字节，数据的净荷（payload）部分预留是1500-20-8=1472字节。如果数据部分大于1472字节，就会出现分片现象。</p>
<h4 id="四、以太网帧格式"><a href="#四、以太网帧格式" class="headerlink" title="四、以太网帧格式"></a><strong><font color="#FF7256">四、以太网帧格式</font></strong></h4><p><img src="http://imgchr.com/images/181f0b.png" alt=""></p>
<ol>
<li><p>其中的源地址和目的地址是指网卡的硬件地址（也叫MAC 地址），长度是48 位，是在网卡出厂时固化的。</p>
</li>
<li><p>注意网卡芯片（例如<a href="http://www.cnblogs.com/feitian629/archive/2012/11/16/2774065.html" target="_blank" rel="external"><strong><font color="#FF7256">DM9000A</font></strong> </a>）收到的数据就是如上所示的一长串数据；其中包括以太网帧头、IP报报头、传输层协议段头、应用层所需数据。</p>
</li>
<li><p>以太网帧中的数据长度规定最小46 字节，最大1500 字节，ARP 和RARP 数据包的长度不够46 字节，要在后面补填充位。最大值1500 称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包度大于拨号链路的MTU了，则需要对数据包进行分片fragmentation）。ifconfig 命令的输出中也有“MTU：1500”。注意，MTU 个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。</p>
</li>
</ol>
<p>ARP协议是通过IP地址获得对应的MAC地址，称为地址解析协议；<br>RARP协议是通过MAC地址来获得对应的IP地址，称为逆向地址解析协议。</p>
<h5 id="1-MTU最大传输单元"><a href="#1-MTU最大传输单元" class="headerlink" title="1.MTU最大传输单元"></a><strong><font color="#FF7256">1.MTU最大传输单元</font></strong></h5><p>这个最大传输单元实际上和链路层协议有着密切的关系，Ethernet帧的结构DMAC+SMAC+Type+Data+CRC，由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64bytes最大不能超过1518bytes，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。（注：小于64Bytes的数据帧一般是由于以太网冲突产生的“碎片”或者线路干扰或者坏的以太网接口产生的，对于大于1518Bytes的数据帧我们一般把它叫做Giant帧，这种一般是由于线路干扰或者坏的以太网口产生）</p>
<p>由于以太网EthernetII最大的数据帧是1518Bytes这样，刨去以太网帧的帧头（DMAC目的MAC地址48bit=6Bytes+SMAC源MAC地址48bit=6Bytes+Type域2bytes）14Bytes和帧尾CRC校验部分4Bytes（这个部门有时候大家也把它叫做FCS），那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。这个就是网络层协议非常关心的地方，因为网络层协议比如IP协议会根据这个值来决定是否把上层传下来的数据进行分片。</p>
<p>当两台远程PC互联的时候，它们的数据需要穿过很多的路由器和各种各样的网络媒介才能到达对端，网络中不同媒介的MTU各不相同，就好比一长段的水管，由不同粗细的水管组成（MTU不同 ）通过这段水管最大水量就要由中间最细的水管决定。</p>
<p>对于网络层的上层协议而言（我们以TCP/IP协议族为例）它们对水管粗细不在意它们认为这个是网络层的事情。网络层IP协议会检查每个从上层协议下来的数据包的大小，并根据本机MTU的大小决定是否作“分片”处理。分片最大的坏处就是降低了传输性能，本来一次可以搞定的事情，分成多次搞定，所以在网络层更高一层（就是传输层）的实现中往往会对此加以注意！有些高层因为某些原因就会要求我这个面包不能切片，我要完整地面包，所以会在IP数据包包头里面加上一个标签：DF（Donot Fragment）。这样当这个IP数据包在一大段网络（水管里面）传输的时候，如果遇到MTU小于IP数据包的情况，转发设备就会根据要求丢弃这个数据包。然后返回一个错误信息给发送者。这样往往会造成某些通讯上的问题，不过幸运的是大部分网络链路都是MTU1500或者大于1500。</p>
<p>对于UDP协议而言，这个协议本身是无连接的协议，对数据包的到达顺序以及是否正确到达不甚关心，所以一般UDP应用对分片没有特殊要求。</p>
<p>对于TCP协议而言就不一样了，这个协议是面向连接的协议，对于TCP协议而言它非常在意数据包的到达顺序以及是否传输中有错误发生。所以有些TCP应用对分片有要求—不能分片（DF）。</p>
<h5 id="2-PPPoE"><a href="#2-PPPoE" class="headerlink" title="2.PPPoE"></a><strong><font color="#FF7256">2.PPPoE</font></strong></h5><p>所谓PPPoE就是在以太网上面跑PPP协议，有人奇怪了，PPP协议和Ethernet不都是链路层协议吗？怎么一个链路层跑到另外一个链路层上面去了，难道升级成网络层协议了不成。其实这是个误区：就是某层协议只能承载更上一层协议。</p>
<p>为什么会产生这种奇怪的需求呢？这是因为随着宽带接入（这种宽带接入一般为Cable Modem或者xDSL或者以太网的接入）由于以太网缺乏认证计费机制而传统运营商是通过PPP协议来对拨号等接入服务进行认证计费的，所以就出了这么一个怪胎：PPPoE。（有关PPPoE的详细介绍参见V大以及本站其他成员的一些介绍文章，我就不啰里啰唆的了）</p>
<p>PPPoE带来了好处，也带来了一些坏处，比如：二次封装耗费资源，降低了传输效能等等，这些坏处俺也不多说了，最大的坏处就是PPPoE导致MTU变小了以太网的MTU是1500，再减去PPP的包头包尾的开销（8Bytes），就变成1492。</p>
<p>如果两台主机之间的某段网络使用了PPPoE那么就会导致某些不能分片的应用无法通讯。</p>
<p>这个时候就需要我们调整一下主机的MTU，通过降低主机的MTU，这样我们就能够顺利地进行通讯了。</p>
<h5 id="3-MSS最大传输大小"><a href="#3-MSS最大传输大小" class="headerlink" title="3.MSS最大传输大小"></a><strong><font color="#FF7256">3.MSS最大传输大小</font></strong></h5><p>TCP协议里面的一个概念。MSS就是TCP数据包每次能够传输的最大数据分段。为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以往往MSS为1460。通讯双方会根据双方提供的MSS值得最小值确定为这次连接的最大MSS值。</p>
<h4 id="五、ARP"><a href="#五、ARP" class="headerlink" title="五、ARP"></a><strong><font color="#FF7256">五、ARP</font></strong></h4><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。</p>
<p>OSI模型把网络工作分为七层，IP地址在OSI模型的第三层，MAC地址在第二层，彼此不直接打交道。在通过以太网发送IP数据包时，需要先封装第三层（32位IP地址）、第二层（48位MAC地址）的报头，但由于发送时只知道目标IP地址，不知道其MAC地址，又不能跨第二、三层，所以需要使用地址解析协议。使用地址解析协议，可根据网络层IP数据包包头中的IP地址信息解析出目标硬件地址（MAC地址）信息，以保证通信的顺利进行。</p>
<h5 id="ARP的工作原理"><a href="#ARP的工作原理" class="headerlink" title="ARP的工作原理"></a><strong><font color="#FF7256">ARP的工作原理</font></strong></h5><ol>
<li><p>首先，每台主机都会在自己的ARP缓冲区 (ARP Cache)中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。</p>
</li>
<li><p>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有﹐就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。</p>
</li>
<li><p>网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址； </p>
</li>
<li>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li>
</ol>
<h5 id="工作要素：ARP缓存"><a href="#工作要素：ARP缓存" class="headerlink" title="工作要素：ARP缓存"></a><strong><font color="#FF7256">工作要素：ARP缓存</font></strong></h5><p>ARP缓存是个用来储存IP地址和MAC地址的缓冲区，其本质就是一个IP地址–&gt;MAC地址的对应表，表中每一个条目分别记录了网络上其他主机的IP地址和对应的MAC地址。每一个以太网或令牌环网络适配器都有自己单独的表。当地址解析协议被询问一个已知IP地址节点的MAC地址时，先在ARP缓存中查看，若存在，就直接返回与之对应的MAC地址，若不存在，才发送ARP请求向局域网查询。</p>
<p>为使广播量最小，ARP维护IP地址到MAC地址映射的缓存以便将来使用。ARP缓存可以包含动态和静态项目。动态项目随时间推移自动添加和删除。每个动态ARP缓存项的潜在生命周期是10分钟。新加到缓存中的项目带有时间戳，如果某个项目添加后2分钟内没有再使用，则此项目过期并从ARP缓存中删除；如果某个项目已在使用，则又收到2分钟的生命周期；如果某个项目始终在使用，则会另外收到2分钟的生命周期，一直到10分钟的最长生命周期。静态项目一直保留在缓存中，直到重新启动计算机为止。</p>
<h5 id="工作媒介：报文"><a href="#工作媒介：报文" class="headerlink" title="工作媒介：报文"></a><strong><font color="#FF7256">工作媒介：报文</font></strong></h5><p><img src="http://imgchr.com/images/arp.png" alt="@ARP协议头"></p>
<p>硬件类型：指明了发送方想知道的硬件接口类型，以太网的值为1；<br>协议类型：指明了发送方提供的高层协议类型，IP为0800（16进制）；<br>硬件地址长度和协议长度：指明了硬件地址和高层协议地址的长度，这样ARP报文就可以在任意硬件和任意协议的网络中使用；<br>操作类型：用来表示这个报文的类型，ARP请求为1，ARP响应为2，RARP请求为3，RARP响应为4；<br>发送方硬件地址（0-3字节）：源主机硬件地址的前3个字节；<br>发送方硬件地址（4-5字节）：源主机硬件地址的后3个字节；<br>发送方IP地址（0-1字节）：源主机硬件地址的前2个字节；<br>发送方IP地址（2-3字节）：源主机硬件地址的后2个字节；<br>目标硬件地址（0-1字节）：目的主机硬件地址的前2个字节；<br>目标硬件地址（2-5字节）：目的主机硬件地址的后4个字节；<br>目标IP地址（0-3字节）：目的主机的IP地址。</p>
<h5 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a><strong><font color="#FF7256">ARP欺骗</font></strong></h5><p>地址解析协议是建立在网络中各个主机互相信任的基础上的，它的诞生使得网络能够更加高效的运行，但其本身也存在缺陷：</p>
<p>ARP地址转换表是依赖于计算机中高速缓冲存储器动态更新的，而高速缓冲存储器的更新是受到更新周期的限制的，只保存最近使用的地址的映射关系表项，这使得攻击者有了可乘之机，可以在高速缓冲存储器更新表项之前修改地址转换表，实现攻击。ARP请求为广播形式发送的，网络上的主机可以自主发送ARP应答消息，并且当其他主机收到应答报文时不会检测该报文的真实性就将其记录在本地的MAC地址转换表，这样攻击者就可以向目标主机发送伪ARP应答报文，从而篡改本地的MAC地址表。ARP欺骗可以导致目标计算机与网关通信失败，更会导致通信重定向，所有的数据都会通过攻击者的机器，因此存在极大的安全隐患。</p>
<p><strong><font color="#FF7256">防御措施</font></strong></p>
<ol>
<li>不要把网络安全信任关系建立在IP基础上或MAC基础上（RARP同样存在欺骗的问题），理想的关系应该建立在IP+MAC基础上。</li>
<li>设置静态的MAC–&gt;IP对应表，不要让主机刷新设定好的转换表。</li>
<li>除非很有必要，否则停止使用ARP，将ARP做为永久条目保存在对应表中。</li>
<li>使用ARP服务器。通过该服务器查找自己的ARP转换表来响应其他机器的ARP广播。</li>
<li>确保这台ARP服务器不被黑。</li>
<li>使用“proxy”代理IP的传输。</li>
<li>使用硬件屏蔽主机。设置好路由，确保IP地址能到达合法的路径（静态配置路由ARP条目），注意，使用交换集线器和网桥无法阻止ARP欺骗。</li>
<li>管理员定期用响应的IP包中获得一个RARP请求，然后检查ARP响应的真实性。</li>
<li>管理员定期轮询，检查主机上的ARP缓存。</li>
<li>使用防火墙连续监控网络。注意有使用SNMP的情况下，ARP的欺骗有可能导致陷阱包丢失。</li>
<li>若感染ARP病毒，可以通过清空ARP缓存、指定ARP对应关系、添加路由信息、使用防病毒软件等方式解决。</li>
</ol>
<h5 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a><strong><font color="#FF7256">RARP</font></strong></h5><p>地址解析协议是根据IP地址获取物理地址的协议，而反向地址转换协议（RARP）是局域网的物理机器从网关服务器的ARP表或者缓存上根据MAC地址请求IP地址的协议，其功能与地址解析协议相反。与ARP相比，RARP的工作流程也相反。首先是查询主机向网路送出一个RARP Request广播封包，向别的主机查询自己的IP地址。这时候网络上的RARP服务器就会将发送端的IP地址用RARP Reply封包回应给查询者，这样查询主机就获得自己的IP地址了。</p>
<h6 id="RARP的工作原理"><a href="#RARP的工作原理" class="headerlink" title="RARP的工作原理"></a><strong><font color="#FF7256">RARP的工作原理</font></strong></h6><ol>
<li><p>发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</p>
</li>
<li><p>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</p>
</li>
<li><p>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</p>
</li>
<li><p>如果不存在，RARP服务器对此不做任何的响应；</p>
</li>
<li><p>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p>
</li>
</ol>
<h5 id="代理ARP"><a href="#代理ARP" class="headerlink" title="代理ARP"></a><strong><font color="#FF7256">代理ARP</font></strong></h5><p>地址解析协议工作在一个网段中，而代理ARP（Proxy ARP，也被称作混杂ARP（Promiscuous ARP） ）工作在不同的网段间，其一般被像路由器这样的设备使用，用来代替处于另一个网段的主机回答本网段主机的ARP请求。例如，主机PC1（192.168.20.66/24）需要向主机PC2（192.168.20.20/24）发送报文，因为主机PC1不知道子网的存在且和目标主机PC2在同一主网络网段，所以主机PC1将发送ARP协议请求广播报文请求192.168.20.20的MAC地址。这时，路由器将识别出报文的目标地址属于另一个子网（注意，路由器的接口IP地址配置的是28位的掩码），因此向请求主机回复自己的硬件地址（0004.dd9e.cca0）。之后，PC1将发往PC2的数据包都发往MAC地址0004.dd9e.cca0（路由器的接口E0/0），由路由器将数据包转发到目标主机PC2。（接下来路由器将为PC2做同样的代理发送数据包的工作）。代理ARP协议使得子网化网络拓扑对于主机来说时透明的（或者可以说是路由器以一个不真实的PC2的MAC地址欺骗了源主机PC1）。</p>
<h5 id="NDP"><a href="#NDP" class="headerlink" title="NDP"></a><strong><font color="#FF7256">NDP</font></strong></h5><p>地址解析协议是IPv4中必不可少的协议，但在IPv6中将不再存在地址解析协议。在IPv6中，地址解析协议的功能将由NDP（邻居发现协议，Neighbor Discovery Protocol）实现，它使用一系列IPv6控制信息报文（ICMPv6）来实现相邻节点（同一链路上的节点）的交互管理，并在一个子网中保持网络层地址和数据链路层地址之间的映射。邻居发现协议中定义了5种类型的信息：路由器宣告、路由器请求、路由重定向、邻居请求和邻居宣告。与ARP相比，NDP可以实现路由器发现、前缀发现、参数发现、地址自动配置、地址解析（代替ARP和RARP）、下一跳确定、邻居不可达检测、重复地址检测、重定向等更多功能。</p>
<blockquote>
<p><strong><font color="#AA7256">NDP与ARP的区别</font></strong></p>
</blockquote>
<ol>
<li>IPv4中地址解析协议是独立的协议，负责IP地址到MAC地址的转换，对不同的数据链路层协议要定义不同的地址解析协议。IPv6中NDP包含了ARP的功能，且运行于因特网控制信息协议ICMPv6上，更具有一般性，包括更多的内容，而且适用于各种数据链路层协议；</li>
<li>地址解析协议以及ICMPv4路由器发现和ICMPv4重定向报文基于广播，而NDP的邻居发现报文基于高效的组播和单播。</li>
</ol>
<h4 id="六、ICMP"><a href="#六、ICMP" class="headerlink" title="六、ICMP"></a><strong><font color="#FF7256">六、ICMP</font></strong></h4><p>ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。它是一个非常重要的协议，它对于网络安全具有极其重要的意义。</p>
<p>它是TCP/IP协议族的一个子协议，属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。ICMP报文在IP帧结构的首部协议类型字段(Protocol 8bit)的值=1。</p>
<p>ICMP包有一个8字节长的包头，其中前4个字节是固定的格式，包含8位类型字段，8位代码字段和16位的校验和，后4个字节根据ICMP包的类型而取不同的值。</p>
<p>ICMP提供一致易懂的出错报告信息。发送的出错报文返回到发送原数据的设备，因为只有发送设备才是出错报文的逻辑接受者。发送设备随后可根据ICMP报文确定发生错误的类型，并确定如何才能更好地重发失败的数据包。但是ICMP唯一的功能是报告问题而不是纠正错误，纠正错误的任务由发送方完成。</p>
<p>我们在网络中经常会使用到ICMP协议，比如我们经常使用的用于检查网络通不通的Ping命令（Linux和Windows中均有），这个“Ping”的过程实际上就是ICMP协议工作的过程。还有其他的网络命令如跟踪路由的Tracert命令也是基于ICMP协议的。</p>
<h5 id="ICMP报文头"><a href="#ICMP报文头" class="headerlink" title="ICMP报文头"></a><strong><font color="#FF7256">ICMP报文头</font></strong></h5><p><img src="http://imgchr.com/images/ICMP.png" alt="ICMP报文"></p>
<p>ICMP全名为(internet control message protocol)网络控制消息协议，ICMP的协议号为1，在IP报文内部，规范定义在RFC792，从技术角度来说，ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其功能主要有：</p>
<p>a . 侦测远端主机是否存在。<br>b . 建立及维护路由资料。<br>c . 重导资料传送路径（ICMP重定向）。<br>d . 资料流量控制。ICMP在沟通之中，主要是透过不同的类别(Type)与代码(Code) 让机器  来识别不同的连线状况。常用的类别如下表所列﹕<br>ICMP 是个非常有用的协议﹐尤其是当我们要对网路连接状况进行判断的时候。</p>
<p>CMP协议对于网络安全具有极其重要的意义。ICMP协议本身的特点决定了它非常容易被用于攻击网络上的路由器和主机。比如，可以利用操作系统规定的ICMP数据包最大尺寸不超过64KB这一规定，向主机发起“Ping of Death”（死亡之Ping）攻击。“Ping of Death” 攻击的原理是：如果ICMP数据包的尺寸超过64KB上限时，主机就会出现内存分配错误，导致TCP/IP堆栈崩溃，致使主机死机。（操作系统已经取消了发送ICMP数据包的大小的限制，解决了这个漏洞）此外，向目标主机长时间、连续、大量地发送ICMP数据包，也会最终使系统瘫痪。大量的ICMP数据包会形成“ICMP风暴”，使得目标主机耗费大量的CPU资源处理，疲于奔命。</p>
<p>防御方法：</p>
<ol>
<li>选择合适的防火墙</li>
</ol>
<p>有效防止ICMP攻击，防火墙应该具有状态检测、细致的数据包完整性检查和很好的过滤规则控制功能。</p>
<p>状态检测防火墙通过跟踪它的连接状态，动态允许外出数据包的响应信息进入防火墙所保护的网络。例如，状态检测防火墙可以记录一个出去的 PING（ICMP Echo Request），在接下来的一个确定的时间段内，允许目标主机响应的ICMP Echo Reply直接发送给前面发出了PING命令的IP，除此之外的其他ICMP Echo Reply消息都会被防火墙阻止。与此形成对比的是，包过滤类型的防火墙允许所有的ICMP Echo Reply消息进入防火墙所保护的网络了。许多路由器和基于Linux内核2.2或以前版本的防火墙系统，都属于包过滤型，用户应该避免选择这些系统。</p>
<p>新的攻击不断出现，防火墙仅仅能够防止已知攻击是远远不够的。通过对所有数据包进行细致分析，删除非法的数据包，防火墙可以防止已知和未知的 DoS攻击。这就要求防火墙能够进行数据包一致性检查。安全策略需要针对ICMP进行细致的控制。因此防火墙应该允许对ICMP类型、代码和包大小进行过滤，并且能够控制连接时间和ICMP包的生成速率。</p>
<ol>
<li>配置防火墙以预防攻击</li>
</ol>
<p>一旦选择了合适的防火墙，用户应该配置一个合理的安全策略。以下是被普遍认可的防火墙安全配置惯例，可供管理员在系统安全性和易用性之间作出权衡。<br>防火墙应该强制执行一个缺省的拒绝策略。除了出站的ICMP Echo Request、出站的ICMP Source Quench、进站的TTL Exceeded和进站的ICMP Destination Unreachable之外，所有的ICMP消息类型都应该被阻止。</p>
<h5 id="ICMP类型"><a href="#ICMP类型" class="headerlink" title="ICMP类型"></a><strong><font color="#FF7256">ICMP类型</font></strong></h5><p>ICMP报文主要有两大功能：查询报文和差错报文。具体类型如下：</p>
<p><img src="http://imgchr.com/images/6a6d58646f6af49d.png" alt=""></p>
<h6 id="ICMP-差错报文"><a href="#ICMP-差错报文" class="headerlink" title="ICMP 差错报文"></a><strong><font color="#FF7256">ICMP 差错报文</font></strong></h6><p>　　当发送一份差错报文时，报文始终包含 IP 的首部和产生 ICMP 差错报文的 IP 数据报的前 8 位字节。这样，接收 ICMP 差错报文的模块就会把它与某个特定的协议(根据 IP 数据报首部中的协议字段来判断)和用户进程(根据包含在 IP 数据报前 8 个字节中的 TCP 或 UDP 报文首部中的 TCP 或 UDP 端口号来判断)联系起来。</p>
<p>　　下面各种情况不会导致产生 ICMP 差错报文：</p>
<p>　　1. ICMP 报文差错(ICMP查询报文可能会产生ICMP差错报文);</p>
<p>　　2. 目的地址是广播地址或多播地址的 IP 数据报;</p>
<p>　　3. 作为链路层广播的数据报;</p>
<p>　　4. 不是 IP 分片的第一片;</p>
<p>　　5. 源地址不是单个主机的数据报，也就是说，源地址不可能是零地址、环回地址、广播地址或多播地址。</p>
<p>　　以下针对 ICMP 差错报文的类型进行分析：</p>
<p>　　1、ICMP 目标不可达消息：IP 路由器无法将 IP 数据报发送给目的地址时，会给发送端主机返回一个目标不可达 ICMP 消息，并在这个消息中显示不可达的具体原因。</p>
<p>　　2、ICMP 重定向消息：如果路由器发现发送端主机使用次优的路径发送数据时，那么它会返回一个 ICMP 重定向消息给这个主机，这个消息包含了最合适的路由信息和源数据。主要发生在路由器持有更好的路由信息的情况下，路由器会通过这个 ICMP 重定向消息给发送端主机一个更合适的发送路由。</p>
<p>　　3、ICMP 超时消息：IP 数据包中有一个字段 TTL(Time to live，生存周期)，它的值随着每经过一个路由器就会减 1，直到减到 0 时该 IP 数据包被丢弃。此时，IP 路由器将发送一个 ICMP 超时消息给发送端主机，并通知该包已被丢弃。</p>
<p>　　4、源抑制消息：当 TCP/IP 主机发送数据到另一主机时，如果速度达到路由器或者链路的饱和状态，路由器发出一个 ICMP 源抑制消息。</p>
<h6 id="ICMP-查询报文"><a href="#ICMP-查询报文" class="headerlink" title="ICMP 查询报文　"></a><strong><font color="#FF7256">ICMP 查询报文</font></strong>　</h6><p>　　ICMP 回送消息：用于进行通信的主机或路由之间，判断发送数据包是否成功到达对端的消息。可以向对端主机发送回送请求消息，也可以接收对端主机回来的回送应答消息。</p>
<p>　　ICMP 地址掩码消息：主要用于主机或路由想要了解子网掩码的情况。可以向那些主机或路由器发送 ICMP 地址掩码请求消息，然后通过接收 ICMP 地址掩码应答消息获取子网掩码信息。</p>
<p>　　ICMP 时间戳消息：可以向那些主机或路由器发送 ICMP 时间戳请求消息，然后通过接收 ICMP 时间戳应答消息获取时间信息。</p>
<h6 id="Ping-程序"><a href="#Ping-程序" class="headerlink" title="Ping 程序　　"></a><strong><font color="#FF7256">Ping 程序</font></strong>　　</h6><p>　　Ping 程序利用 ICMP 回显请求报文和回显应答报文(而不用经过传输层)来测试目标主机是否可达。它是一个检查系统连接性的基本诊断工具。</p>
<p>　　ICMP 回显请求和 ICMP 回显应答报文是配合工作的。当源主机向目标主机发送了 ICMP 回显请求数据包后，它期待着目标主机的回答。目标主机在收到一个 ICMP 回显请求数据包后，它会交换源、目的主机的地址，然后将收到的 ICMP 回显请求数据包中的数据部分原封不动地封装在自己的 ICMP 回显应答数据包中，然后发回给发送 ICMP 回显请求的一方。如果校验正确，发送者便认为目标主机的回显服务正常，也即物理连接畅通。</p>
<h6 id="Traceroute-程序"><a href="#Traceroute-程序" class="headerlink" title="Traceroute 程序　"></a><strong><font color="#FF7256">Traceroute 程序</font></strong>　</h6><p>　　Traceroute 程序主要用来侦测源主机到目的主机之间所经过的路由的情况。</p>
<p>　　Traceroute 使用 ICMP 报文和 IP 首部中的 TTL 字段，它充分利用了 ICMP 超时消息。其原理很简单，开始时发送一个 TTL 字段为 1 的 UDP 数据报，而后每次收到 ICMP 超时萧后，按顺序再发送一个 TTL 字段加 1 的 UDP 数据报，以确定路径中的每个路由器，而每个路由器在丢弃 UDP 数据报时都会返回一个 ICMP 超时报文，而最终到达目的主机后，由于 ICM P选择了一个不可能的值作为 UDP 端口(大于30000)。这样目的主机就会发送一个端口不可达的 ICMP 差错报文。</p>
<h4 id="七、IGMP协议"><a href="#七、IGMP协议" class="headerlink" title="七、IGMP协议　"></a><strong><font color="#FF7256">七、IGMP协议</font></strong>　</h4><p>IGMP(Internet Group Manage Protocol)：Internet组管理协议,提供internet网际多点<br>传送的功能,即将一个ip包拷贝给多个host，windows系列采用了这个协议，因为此项技术尚不成熟，因此被一些人用来攻击windows系统，尤其是对win98，因为对win95有oob攻击。受到IGMP攻击的症状是首先出现蓝屏,然后网速变得极慢,有的甚至鼠标,键盘均不管用，非得重启不可。</p>
<p>正如ICMP一样， IGMP 也被当作IP 层的一部分。IGMP报文通过IP数据报进行传输。不像我们已经见到的其他协议， IGMP有固定的报文长度，没有可选数据。图13-1显示了IGMP报文如何封装在IP数据报中。</p>
<p><img src="http://imgchr.com/images/IGMP2.png" alt="enter image description here"></p>
<p>IGMP报文通过IP首部中协议字段值为2来指明。</p>
<h5 id="IGMP报文"><a href="#IGMP报文" class="headerlink" title=" IGMP报文　"></a><strong><font color="#FF7256"> IGMP报文</font></strong>　</h5><p><img src="http://imgchr.com/images/igmp.png" alt="enter image description here"></p>
<p>　　这是版本为1的IGMP.IGMP类型为1说明是由多播路由器发出的查询报文，为2说明是主机发出的报告报文。检验和的计算和ICMP协议相同。</p>
<p>　　组地址为D类IP地址。在查询报文中组地址设置为0，在报告报文中组地址为要参加的组地址。</p>
<h5 id="单播-unicast"><a href="#单播-unicast" class="headerlink" title="单播(unicast)　"></a><strong><font color="#FF7256">单播(unicast)</font></strong>　</h5><p>单播是说，对特定的主机进行数据传送。例如给某一个主机发送IP数据包。这时候，数据链路层给出的数据头里面是非常具体的目的地址，对于以太网来 说，就是网卡的MAC地址（不是FF-FF-FF-FF-FF-FF这样的地址）。现在的具有路由功能的主机应该可以将单播数据定向转发，而目的主机的网 络接口则可以过滤掉和自己MAC地址不一致的数据。</p>
<h5 id="广播-unicast"><a href="#广播-unicast" class="headerlink" title="广播(unicast)　"></a><strong><font color="#FF7256">广播(unicast)</font></strong>　</h5><p>广播是主机针对某一个网络上的所有主机发送数据包。这个网络可能是网络，可能是子网，还可能是所有的子网。如果是网络，例如A类网址的广播就是 netid.255.255.255，如果是子网，则是netid.netid.subnetid.255；如果是所有的子网（B类IP）则是则是 netid.netid.255.255。广播所用的MAC地址FF-FF-FF-FF-FF-FF。网络内所有的主机都会收到这个广播数据，网卡只要把 MAC地址为FF-FF-FF-FF-FF-FF的数据交给内核就可以了。一般说来ARP，或者路由协议RIP应该是以广播的形式播发的。</p>
<h5 id="多播-multicast"><a href="#多播-multicast" class="headerlink" title="多播(multicast)　"></a><strong><font color="#FF7256">多播(multicast)</font></strong>　</h5><p>　　多播路由器使用IGMP报文来记录与该路由器相连网络中组成员的变化情况。使用规则如下：</p>
<p>　　1） 当第一个进程加入一个组时，主机就发送一个IGMP报告。如果一个主机的多个进程加入同一组，只发送一个IGMP报告。这个报告被发送到进程加入组所在的同一接口上。</p>
<p>　　2） 进程离开一个组时，主机不发送IGMP报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的IGMP查询中就不再发送报告报文。</p>
<p>　　3） 多播路由器定时发送IGMP查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个IGMP查询。因为路由器希望主机对它加入的每个多播组均发回一个报告，因此IGMP查询报文中的组地址被设置为0.</p>
<p>　　4） 主机通过发送IGMP报告来响应一个IGMP查询，对每个至少还包含一个进程的组均要发回IGMP报告。</p>
<p>　　使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使用相应的多播链路层地址）还拥有属于那个组主机的接口上。</p>
<p>可以说广播是多播的特例，多播就是给一组特定的主机（多播组）发送数据，这样，数据的播发范围会小一些(实际上播发的范围一点也没有变小)，多播的MAC地址是最高字节的低位为一，例 如01-00-00-00-00-00。多播组的地址是D类IP，规定是224.0.0.0-239.255.255.255。 </p>
<p>虽然多播比较特殊，但是究其原理，多播的数据还是要通过数据链路层进行MAC地址绑定然后进行发送。所以一个以太网卡在绑定了一个多播IP地址之后，必 定还要绑定一个多播的MAC地址，才能使得其可以像单播那样工作。这个多播的IP和多播MAC地址有一个对应的算法，在书的p133到p134之间。可以看到 这个对应不是一一对应的，主机还是要对多播数据进行过滤。</p>
<p>广播和多播的性质是一样的，路由器会把数据放到局域网里面，然后网卡对这些数据进行过滤，只拿到自己打算要的数据，比如自己感兴趣的多播数据，自己感兴趣的组播数据。当一个主机运行了一个处理某一个多播IP的进程的时候，这个进程会给网卡绑定一个虚拟的多播mac地址，并做出来一个多播 ip。这样，网卡就会让带有这个多播mac地址的数据进来，从而实现通信，而那些没有监听这些数据的主机就会把这些数据过滤掉，换句话说，多播是让主机 的内核轻松了，而网卡负担加重。</p>
<h5 id="IGMP的工作过程"><a href="#IGMP的工作过程" class="headerlink" title="IGMP的工作过程　"></a><strong><font color="#FF7256">IGMP的工作过程</font></strong>　</h5><ol>
<li><p>当主机加入一个新的工作组时,它发送一个igmp host membership report的报文给全部主机组,宣布此成员关系.本地多点广播路由器接受到这个报文后,向Internet上的其他多路广播路由器传播这个关系信息,建立必要的路由.与此同时,在主机的网络接口上将ip主机组地址映射为mac地址,并重新设置地址过滤器.</p>
</li>
<li><p>为了处理动态的成员关系,本地多路广播路由器周期性的轮询本地网络上的主机,以便确定在各个主机组有哪些主机,这个轮询过程是通过发送igmp host membership query报文来实现的,这个报文发送给全部主机组,且报文的ttl域设为1,以确保报文不会传送到lan以外.受到报文的主机组成员会发送响应报文.如果所有的主机组成员同时响应的话,就可能造成网络阻塞.IGMP协议采用了随机延时的方法来避免这个情况.这样就保证了在同一时刻每个主机组中只有一个成员在发送响应报文。</p>
</li>
</ol>
<p>IGMP的作用在于，让其他所有需要知道自己处于哪个多播组的主机和路由器知道自己的状态。一般多播路由器根本不需要知道某一个多播组里面有多少个主机，而只要知道自己的子网内还有没有处于某个多播组的主机就可以了。只要某一个多播组还有一台主机，多播路由器就会把数据传输出去，这样，接受方就会通过网卡过滤功能来得到自己想要的数据。为了知道多播组的信息，多播路由器需要定时的发送IGMP查询，IGMP的格式可以看书，各个多播组里面的主机要根据查询来回复自己的状态。路由器来决定有几个多播组，自己要对某一个多播组发送什么样的数据。</p>
<p>这种查询回应数据报的TTL一般是1，而且就算是出错也不产生ICMP差错（没必要）。</p>
<p>附上部分参考链接：</p>
<p><a href="http://network.51cto.com/art/201307/405259.htm" target="_blank" rel="external">http://network.51cto.com/art/201307/405259.htm</a><br><a href="http://network.chinabyte.com/23/13155523.shtml" target="_blank" rel="external">http://network.chinabyte.com/23/13155523.shtml</a><br><a href="http://blog.csdn.net/xifeijian/article/details/44261821" target="_blank" rel="external">http://blog.csdn.net/xifeijian/article/details/44261821</a><br><a href="http://blog.chinaunix.net/uid-26833883-id-3627644.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26833883-id-3627644.html</a><br><a href="http://blog.csdn.net/a19881029/article/details/38091243/" target="_blank" rel="external">http://blog.csdn.net/a19881029/article/details/38091243/</a><br><a href="http://www.cnblogs.com/fengzanfeng/articles/1339347.html" target="_blank" rel="external">http://www.cnblogs.com/fengzanfeng/articles/1339347.html</a><br><a href="http://blog.csdn.net/chengqianyun2002/article/details/1699235" target="_blank" rel="external">http://blog.csdn.net/chengqianyun2002/article/details/1699235</a><br><a href="http://www.cnblogs.com/feitian629/archive/2012/11/16/2774065.html" target="_blank" rel="external">http://www.cnblogs.com/feitian629/archive/2012/11/16/2774065.html</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/http-https/" rel="tag"># http/https</a>
          
            <a href="/tags/retrofit2/" rel="tag"># retrofit2</a>
          
            <a href="/tags/OkHttp3/" rel="tag"># OkHttp3</a>
          
            <a href="/tags/Socket/" rel="tag"># Socket</a>
          
            <a href="/tags/TCP-IP/" rel="tag"># TCP/IP</a>
          
            <a href="/tags/UDP/" rel="tag"># UDP</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/09/Hexo/" rel="next" title="Hexo">
                <i class="fa fa-chevron-left"></i> Hexo
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/03/HTTP-HTTPS-SOCKET/" rel="prev" title="HTTP/HTTPS/SOCKET">
                HTTP/HTTPS/SOCKET <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/photo-1-2.jpeg"
               alt="peanut" />
          <p class="site-author-name" itemprop="name">peanut</p>
           
              <p class="site-description motion-element" itemprop="description">天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣！</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">53</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/" target="_blank" title="jianshu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  jianshu
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/peanutDD" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP协议分层"><span class="nav-number">1.</span> <span class="nav-text">TCP/IP协议分层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IP地址"><span class="nav-number">1.1.</span> <span class="nav-text">IP地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RFC"><span class="nav-number">1.2.</span> <span class="nav-text"> RFC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#端口号-port"><span class="nav-number">1.3.</span> <span class="nav-text"> 端口号(port)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#推荐协议"><span class="nav-number">1.3.1.</span> <span class="nav-text"> 推荐协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#可选协议"><span class="nav-number">1.3.2.</span> <span class="nav-text"> 可选协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#端口号分类"><span class="nav-number">1.3.3.</span> <span class="nav-text"> 端口号分类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#逻辑端口"><span class="nav-number">1.3.3.1.</span> <span class="nav-text"> 逻辑端口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#动态端口"><span class="nav-number">1.3.3.2.</span> <span class="nav-text"> 动态端口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#保留端口"><span class="nav-number">1.3.3.3.</span> <span class="nav-text"> 保留端口</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看端口方式"><span class="nav-number">1.3.4.</span> <span class="nav-text"> 查看端口方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#65535个端口号使用规则"><span class="nav-number">1.3.5.</span> <span class="nav-text"> 65535个端口号使用规则</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用编程接口"><span class="nav-number">1.4.</span> <span class="nav-text"> 应用编程接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#四类接口"><span class="nav-number">1.4.1.</span> <span class="nav-text">四类接口</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-文件类接口"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">1.文件类接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-远程过程调用（RPC-Remote-Procedure-Call-Protocol）"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">2.远程过程调用（RPC: Remote Procedure Call Protocol）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-数据查询接口"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">3.数据查询接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-数据通信类接口"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">4.数据通信类接口</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一、TCP"><span class="nav-number">2.</span> <span class="nav-text">一、TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP报文头"><span class="nav-number">2.1.</span> <span class="nav-text">TCP报文头</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-端口号"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.端口号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-序列号"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.序列号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-偏移-首部长度-Offset"><span class="nav-number">2.1.3.</span> <span class="nav-text">3.偏移 (首部长度 Offset)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-预留6位-Reserved"><span class="nav-number">2.1.4.</span> <span class="nav-text">4.预留6位 (Reserved)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-TCP-Flags"><span class="nav-number">2.1.5.</span> <span class="nav-text">5.TCP Flags</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-窗口大小-window"><span class="nav-number">2.1.6.</span> <span class="nav-text">6.窗口大小 (window)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-校验和-CheckSum"><span class="nav-number">2.1.7.</span> <span class="nav-text">7.校验和 (CheckSum)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-紧急指针-：-UrgentPointer"><span class="nav-number">2.1.8.</span> <span class="nav-text">8.紧急指针 ：(UrgentPointer)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-TCP选项-Options"><span class="nav-number">2.1.9.</span> <span class="nav-text">9.TCP选项 (Options)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三次握手建立连接-three-way-handshake"><span class="nav-number">2.2.</span> <span class="nav-text">三次握手建立连接 (three-way handshake)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据传输"><span class="nav-number">2.3.</span> <span class="nav-text">数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-超时重传"><span class="nav-number">2.3.1.</span> <span class="nav-text">a.超时重传</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#重传定时器-Retransmission-Timer-："><span class="nav-number">2.3.1.1.</span> <span class="nav-text">重传定时器(Retransmission Timer)：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#坚持定时器-Persistent-Timer-："><span class="nav-number">2.3.1.2.</span> <span class="nav-text">坚持定时器(Persistent Timer)：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#保活定时器-Keeplive-Timer-："><span class="nav-number">2.3.1.3.</span> <span class="nav-text">保活定时器(Keeplive Timer)：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2MSL定时器（Time-Wait-Timer-："><span class="nav-number">2.3.1.4.</span> <span class="nav-text">2MSL定时器（Time_Wait Timer)：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#指数退避："><span class="nav-number">2.3.1.5.</span> <span class="nav-text">指数退避：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-往返时间测量"><span class="nav-number">2.3.1.6.</span> <span class="nav-text">1.往返时间测量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-拥塞避免算法"><span class="nav-number">2.3.1.7.</span> <span class="nav-text">2.拥塞避免算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-快速重传和快速恢复算法"><span class="nav-number">2.3.1.8.</span> <span class="nav-text">3.快速重传和快速恢复算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-ICMP（Internet-Control-Message-Protocol）Internet控制报文协议）差错"><span class="nav-number">2.3.1.9.</span> <span class="nav-text">4.ICMP（Internet Control Message Protocol）Internet控制报文协议）差错</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-重新分组"><span class="nav-number">2.3.1.10.</span> <span class="nav-text">5.重新分组</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-快速重传"><span class="nav-number">2.3.2.</span> <span class="nav-text">b.快速重传</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-流量控制-滑动窗口技术"><span class="nav-number">2.3.3.</span> <span class="nav-text">c.流量控制(滑动窗口技术)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#d-拥塞控制"><span class="nav-number">2.3.4.</span> <span class="nav-text">d.拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四次挥手断开连接"><span class="nav-number">2.4.</span> <span class="nav-text">四次挥手断开连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、UDP"><span class="nav-number">3.</span> <span class="nav-text">二、UDP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、IP协议"><span class="nav-number">4.</span> <span class="nav-text">三、IP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IP报文头格式"><span class="nav-number">4.0.1.</span> <span class="nav-text">IP报文头格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IP路由选择"><span class="nav-number">4.0.2.</span> <span class="nav-text">IP路由选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#子网编码"><span class="nav-number">4.0.3.</span> <span class="nav-text"> 子网编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#特殊的IP"><span class="nav-number">4.0.4.</span> <span class="nav-text"> 特殊的IP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分片解释"><span class="nav-number">4.0.5.</span> <span class="nav-text">分片解释</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、以太网帧格式"><span class="nav-number">4.1.</span> <span class="nav-text">四、以太网帧格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-MTU最大传输单元"><span class="nav-number">4.1.1.</span> <span class="nav-text">1.MTU最大传输单元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-PPPoE"><span class="nav-number">4.1.2.</span> <span class="nav-text">2.PPPoE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-MSS最大传输大小"><span class="nav-number">4.1.3.</span> <span class="nav-text">3.MSS最大传输大小</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、ARP"><span class="nav-number">4.2.</span> <span class="nav-text">五、ARP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ARP的工作原理"><span class="nav-number">4.2.1.</span> <span class="nav-text">ARP的工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#工作要素：ARP缓存"><span class="nav-number">4.2.2.</span> <span class="nav-text">工作要素：ARP缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#工作媒介：报文"><span class="nav-number">4.2.3.</span> <span class="nav-text">工作媒介：报文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARP欺骗"><span class="nav-number">4.2.4.</span> <span class="nav-text">ARP欺骗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RARP"><span class="nav-number">4.2.5.</span> <span class="nav-text">RARP</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#RARP的工作原理"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">RARP的工作原理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代理ARP"><span class="nav-number">4.2.6.</span> <span class="nav-text">代理ARP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NDP"><span class="nav-number">4.2.7.</span> <span class="nav-text">NDP</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、ICMP"><span class="nav-number">4.3.</span> <span class="nav-text">六、ICMP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ICMP报文头"><span class="nav-number">4.3.1.</span> <span class="nav-text">ICMP报文头</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ICMP类型"><span class="nav-number">4.3.2.</span> <span class="nav-text">ICMP类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ICMP-差错报文"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">ICMP 差错报文</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ICMP-查询报文"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">ICMP 查询报文　</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Ping-程序"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">Ping 程序　　</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Traceroute-程序"><span class="nav-number">4.3.2.4.</span> <span class="nav-text">Traceroute 程序　</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七、IGMP协议"><span class="nav-number">4.4.</span> <span class="nav-text">七、IGMP协议　</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IGMP报文"><span class="nav-number">4.4.1.</span> <span class="nav-text"> IGMP报文　</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#单播-unicast"><span class="nav-number">4.4.2.</span> <span class="nav-text">单播(unicast)　</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#广播-unicast"><span class="nav-number">4.4.3.</span> <span class="nav-text">广播(unicast)　</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多播-multicast"><span class="nav-number">4.4.4.</span> <span class="nav-text">多播(multicast)　</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IGMP的工作过程"><span class="nav-number">4.4.5.</span> <span class="nav-text">IGMP的工作过程　</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">peanut</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

</body>
</html>
