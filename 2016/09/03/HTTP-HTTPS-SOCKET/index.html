<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="http/https,retrofit2,OkHttp3,Socket,TCP,GET/POST," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="写在本文之前先声明一点：本文是作者通过收集的文章以及自己的看法统一精心整理而成的，主要的参考链接已给出，若想更加全面的理解HTTP协议，建议阅读《图解HTTP》一书，本文花费作者大量时间和精力，未经作者允许禁止转载！  http://www.androidchina.net/4710.htmlhttp://www.androidchina.net/3934.htmlhttp://www.andr">
<meta name="keywords" content="http&#x2F;https,retrofit2,OkHttp3,Socket,TCP,GET&#x2F;POST">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP&#x2F;HTTPS&#x2F;SOCKET">
<meta property="og:url" content="http://yoursite.com/2016/09/03/HTTP-HTTPS-SOCKET/index.html">
<meta property="og:site_name" content="鱼人孑">
<meta property="og:description" content="写在本文之前先声明一点：本文是作者通过收集的文章以及自己的看法统一精心整理而成的，主要的参考链接已给出，若想更加全面的理解HTTP协议，建议阅读《图解HTTP》一书，本文花费作者大量时间和精力，未经作者允许禁止转载！  http://www.androidchina.net/4710.htmlhttp://www.androidchina.net/3934.htmlhttp://www.andr">
<meta property="og:image" content="http://storage1.imgchr.com/images/TCP-IP1cee2.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/IP-TCP-DNS-HTTP1.png">
<meta property="og:image" content="http://i4.buimg.com/567571/b4c94e43e3504e70.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/318e4ee4d75de441.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/1691b2.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/URL977f1.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/19c2d6.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/upgrade.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/Via.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/Accept.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/Authorization.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/HOST.png">
<meta property="og:image" content="http://storage2.imgchr.com/If-Match.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/If-Modified-Since.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/if-no-match.png">
<meta property="og:image" content="http://storage2.imgchr.com/If-Range.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/If-Range1.png">
<meta property="og:image" content="http://storage2.imgchr.com/Max-Forwards1.png">
<meta property="og:image" content="http://storage2.imgchr.com/Max-Forwards2.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/Max-Forwards3.png">
<meta property="og:image" content="http://storage2.imgchr.com/Referer.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/AGE.png">
<meta property="og:image" content="http://storage2.imgchr.com/ETag.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/ETag1.png">
<meta property="og:image" content="http://storage2.imgchr.com/location1.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/retry.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/Vary.png">
<meta property="og:image" content="http://storage2.imgchr.com/md5.png">
<meta property="og:image" content="http://storage2.imgchr.com/SPDY.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/WebSocket.png">
<meta property="og:image" content="http://storage2.imgchr.com/HTTPS.png">
<meta property="og:image" content="http://storage2.imgchr.com/HTTPSd4998.png">
<meta property="og:image" content="http://i2.buimg.com/567571/52da9cfd2c9ef658.png">
<meta property="og:image" content="http://storage1.imgchr.com/images/OSI.gif">
<meta property="og:updated_time" content="2017-06-03T06:50:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HTTP&#x2F;HTTPS&#x2F;SOCKET">
<meta name="twitter:description" content="写在本文之前先声明一点：本文是作者通过收集的文章以及自己的看法统一精心整理而成的，主要的参考链接已给出，若想更加全面的理解HTTP协议，建议阅读《图解HTTP》一书，本文花费作者大量时间和精力，未经作者允许禁止转载！  http://www.androidchina.net/4710.htmlhttp://www.androidchina.net/3934.htmlhttp://www.andr">
<meta name="twitter:image" content="http://storage1.imgchr.com/images/TCP-IP1cee2.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/09/03/HTTP-HTTPS-SOCKET/"/>





  <title>HTTP/HTTPS/SOCKET | 鱼人孑</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  

  <div class="container  page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">鱼人孑</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/03/HTTP-HTTPS-SOCKET/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="peanut">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo-1-2.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鱼人孑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">HTTP/HTTPS/SOCKET</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-03T16:49:51+08:00">
                2016-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络请求及框架/" itemprop="url" rel="index">
                    <span itemprop="name">网络请求及框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2016/09/03/HTTP-HTTPS-SOCKET/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2016/09/03/HTTP-HTTPS-SOCKET/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p><strong><font color="#FF7256">写在本文之前先声明一点：本文是作者通过收集的文章以及自己的看法统一精心整理而成的，主要的参考链接已给出，若想更加全面的理解HTTP协议，建议阅读《图解HTTP》一书，本文花费作者大量时间和精力，未经作者允许禁止转载！</font></strong></p>
</blockquote>
<p><a href="http://www.androidchina.net/4710.html" target="_blank" rel="external">http://www.androidchina.net/4710.html</a><br><a href="http://www.androidchina.net/3934.html" target="_blank" rel="external">http://www.androidchina.net/3934.html</a><br><a href="http://www.androidchina.net/5469.html" target="_blank" rel="external">http://www.androidchina.net/5469.html</a><br><a href="http://www.jianshu.com/p/de262cfbb4ef" target="_blank" rel="external">http://www.jianshu.com/p/de262cfbb4ef</a><br><a href="http://www.jianshu.com/p/e544b7a76dac" target="_blank" rel="external">http://www.jianshu.com/p/e544b7a76dac</a><br><a href="http://www.jianshu.com/p/8565912949bb#" target="_blank" rel="external">http://www.jianshu.com/p/8565912949bb#</a><br><a href="http://my.oschina.net/yuanxulong/blog/355055" target="_blank" rel="external">http://my.oschina.net/yuanxulong/blog/355055</a><br><a href="http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html" target="_blank" rel="external">http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html</a></p>
<h3 id="一、HTTP"><a href="#一、HTTP" class="headerlink" title="一、HTTP"></a><strong><font color="#FF7256">一、HTTP</font></strong></h3><p>http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。它不涉及数据包传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p>
<p><img src="http://storage1.imgchr.com/images/TCP-IP1cee2.png" alt="enter image description here"></p>
<p>HTTP主要缺点：</p>
<ol>
<li><p>通信使用明文（不加密），内容可能会被窃听</p>
</li>
<li><p>不验证通信方的身份，因此有可能遭遇伪装</p>
</li>
<li><p>无法证明报文的完整性，所以有可能已遭篡改</p>
</li>
</ol>
<p>这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题。</p>
<p>除此之外，HTTP 本身还有很多缺点。而且，还有像某些特定的 Web 服务器和特定的 Web 浏览器在实际应用中存在的不足（也可以说成是脆弱性或安全漏洞），另外，用 Java 和 PHP 等编程语言开发的 Web 应用也可能存在安全漏洞。</p>
<p><strong><font color="#FF7256">通信使用明文可能会被窃听</font></strong></p>
<ol>
<li><p>TCP/IP 是可能被窃听的网络<br>如果要问为什么通信时不加密是一个缺点，这是因为，按 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。</p>
</li>
<li><p>加密处理防止被窃听<br> 通信的加密<br> 内容的加密</p>
</li>
</ol>
<p><strong><font color="#FF7256">不验证通信方的身份就可能遭遇伪装</font></strong></p>
<ol>
<li>任何人都可发起请求</li>
</ol>
<p>在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下）。</p>
<p>HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。</p>
<p>a. 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</p>
<p>b. 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</p>
<p>c. 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。</p>
<p>d. 无法判定请求是来自何方、出自谁手。</p>
<p>e. 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。</p>
<ol>
<li>查明对手的证书</li>
</ol>
<p><strong><font color="#FF7256">无法证明报文完整性，可能已遭篡改</font></strong></p>
<ol>
<li>接收到的内容可能有误<br>由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。<br>换句话说，没有任何办法确认，发出的请求 / 响应和接收到的请求 / 响应是前后相同的。<br>比如，从某个 Web 网站上下载内容，是无法确定客户端下载的文件和服务器上存放的文件是否前后一致的。文件内容在传输途中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的。<br>像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）。</li>
<li>如何防止篡改<br>a. 虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。<br>b. 提供文件下载服务的 Web 网站也会提供相应的以 PGP（Pretty Good Privacy，完美隐私）创建的数字签名及 MD5 算法生成的散列值。PGP 是用来证明创建文件的数字签名，MD5 是由单向函数生成的散列值。不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。浏览器无法自动帮用户检查。</li>
</ol>
<p>可惜的是，用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。</p>
<p>为了有效防止这些弊端，有必要使用 HTTPS。SSL 提供认证和加密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。下节我们介绍 HTTPS 的相关内容。<br><strong><font color="#FF7256">关键词：</font></strong></p>
<blockquote>
<p><strong><font color="#FF7256">URL：uniform resource location 统一资源定位符</font></strong></p>
</blockquote>
<p>　　访问web的一个字符串地址</p>
<blockquote>
<p><strong><font color="#FF7256">URI：uniform resource identifier 统一资源标识符</font></strong></p>
</blockquote>
<p>　　这也就是说，URI是一种资源的标识；而URL也是一种URI，也是一种资源的标识，但它也指明了如何定位Locate到这个资源。</p>
<p>　　URI是一种抽象的资源标识，既可以是绝对的，也可以是相对的。但是URL是一种URI，它指明了定位的信息，必须是绝对的。而我们平时所说的相对地址，仅仅是相对于另一个绝对地址而言。</p>
<blockquote>
<p><strong><font color="#FF7256">RFC：reqeust for comments 征求修正意见书</font></strong></p>
</blockquote>
<p>　　RFC素有网络知识圣经之称，规定了网络中协议的基本内容。因此许多的不同系统的应用程序才可以互相访问。</p>
<p><img src="http://storage1.imgchr.com/images/IP-TCP-DNS-HTTP1.png" alt="enter image description here"></p>
<blockquote>
<p><a href="http://www.androidchina.net/4892.html" target="_blank" rel="external">Android HTTP网络请求的异步实现</a>（转载）</p>
</blockquote>
<p>HTTP报文如图所示：</p>
<p><img src="http://i4.buimg.com/567571/b4c94e43e3504e70.png" alt="enter image description here"></p>
<h4 id="协议版本："><a href="#协议版本：" class="headerlink" title="协议版本："></a><strong><font color="#FF7256">协议版本：</font></strong></h4><h5 id="HTTP-0-9："><a href="#HTTP-0-9：" class="headerlink" title="HTTP/0.9："></a><strong><font color="#FF7256">HTTP/0.9：</font></strong></h5><p>只有一个命令GET</p>
<blockquote>
<p><strong><font color="#FF7256">GET /index.html</font></strong></p>
</blockquote>
<p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。</p>
<p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;body&gt;Hello World&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>服务器发送完毕，就关闭TCP连接。</p>
<h5 id="HTTP-1-0："><a href="#HTTP-1-0：" class="headerlink" title="HTTP/1.0："></a><strong><font color="#FF7256">HTTP/1.0：</font></strong></h5><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p>
<p>其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。</p>
<p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p>
<p>其他的新增功能还包括<a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="external">状态码（status code）</a>、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>
<p>当前浏览器客户端与服务器端建立连接之后，只能发送一次请求，一次请求之后连接关闭。</p>
<p><img src="http://storage1.imgchr.com/images/318e4ee4d75de441.png" alt="enter image description here"></p>
<p>报文首部：客户端和服务器处理时七至关重要作用的信息几乎都在这里面；</p>
<p>报文主体：所需要的用户和资源的信息都在这里面。</p>
<p>其中空行用于区分报文首部和报文主体内容，是由一个回车符和一个换行符组成。</p>
<p>无论是请求报文还是响应报文都需要有报文首部，当然报文主体有的请求报文是没有的。<br>　　<br>　　1. 请求行包含用于请求的方法，请求 URI 和 HTTP 版本。</p>
<p>　　2. 状态行包含表明响应结果的状态码，原因短语和 HTTP 版本。<br>　　<br>状态行格式如下：</p>
<p>HTTP-Version Status-Code Reason-Phrase CRLF</p>
<p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。</p>
<p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p>
<p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p>
<p>常见状态代码、状态描述、说明：</p>
<p>200 OK      //客户端请求成功<br>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden  //服务器收到请求，但是拒绝提供服务<br>404 Not Found  //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error //服务器发生不可预期的错误<br>503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">eg</span>: HTTP/1.1 200 OK （CRLF）</div></pre></td></tr></table></figure></p>
<p>区别：</p>
<p>　　1. 请求行中指定的是HTTP版本和请求的方式（GET\POST等）。</p>
<p>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF  </p>
<p>其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</p>
<p>请求方法（所有方法全为大写）有多种，各个方法的解释如下：</p>
<p>GET     请求获取Request-URI所标识的资源</p>
<p>POST    在Request-URI所标识的资源后附加新的数据</p>
<p>HEAD    请求获取由Request-URI所标识的资源的响应消息报头</p>
<p>PUT     请求服务器存储一个资源，并用Request-URI作为其标识</p>
<p>DELETE  请求服务器删除Request-URI所标识的资源</p>
<p>TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断</p>
<p>CONNECT 保留将来使用</p>
<p>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</p>
<p>应用举例：</p>
<p>GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg： GET /form.html HTTP/1.1 (CRLF)</div></pre></td></tr></table></figure></p>
<p>POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg：POST /reg.jsp HTTP/ (CRLF)</div></pre></td></tr></table></figure></p>
<p>Accept:image/gif,image/x-xbit,… (CRLF)<br>…<br>HOST:www.guet.edu.cn (CRLF)<br>Content-Length:22 (CRLF)<br>Connection:Keep-Alive (CRLF)<br>Cache-Control:no-cache (CRLF)</p>
<p>CRLF：该CRLF表示消息报头已经结束，在此之前为消息报头</p>
<p>user=jeffrey&amp;pwd=1234  //此行以下为提交的数据</p>
<p>HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p>
<p>　　2. 状态行中指定了HTTP版本和返回的状态码以及短语。</p>
<p>　　3. 并且，请求首部与相应首部中拥有不同的属性。</p>
<p>　　4. 如何发送http有很多种方式，但是最常用的就是POST和GET。</p>
<p>　　其他的有些出于安全性的考虑一般都不建议使用。那么POST与GET有什么区别呢？</p>
<p>　　1. 使用目标不同：</p>
<p>　　POST与GET都用于获取信息，但是GET方式仅仅是查询，并不对服务器上的内容产生任何作用结果；每次GET的内容都是相同的。</p>
<p>　　POST则常用于发送一定的内容进行某些修改操作。</p>
<p>　　2. 大小不同：</p>
<p>　　由于不同的浏览器对URL的长度大小有一定的字符限制，因此由于GET方式放在URL的首部中，自然也跟着首先，但是具体的大小要依浏览器而定。</p>
<p>　　POST方式则是把内容放在报文内容中，因此只要报文的内容没有限制，它的大小就没有限制。</p>
<p>　　3. 安全性不同：</p>
<p>　　上面也说了GET是直接添加到URL后面的，直接就可以在URL中看到内容。</p>
<p>　　而POST是放在报文内部的，用户无法直接看到。</p>
<p>　　总的来说，GET用于获取某个内容，POST用于提交某种数据请求。</p>
<p>　　按照使用场景来说，一般用户注册的内容属于私密的，这应该使用POST方式；而针对某一内容的查询，为了快速的响应，可以使用GET方式。</p>
<p>在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。
　　</p>
<h6 id="请求报文格式："><a href="#请求报文格式：" class="headerlink" title="请求报文格式："></a><strong><font color="#FF7256">请求报文格式：</font></strong></h6><p><img src="http://storage1.imgchr.com/images/1691b2.png" alt="enter image description here"></p>
<p>　<br><strong><font color="#FF7256">请求行：</font></strong></p>
<p>请求行（Request Line）分为三个部分：请求方法、请求地址和协议及版本，以CRLF(\r\n)结束。</p>
<p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE,最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p>
<p>在了解请求地址之前，先了解一下URL的构成：</p>
<p><img src="http://storage1.imgchr.com/images/URL977f1.png" alt="enter image description here"></p>
<p>PATH是URL主机以后的部分，即包含了Query String，如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">URL</th>
<th style="text-align:center">PATH</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://http://www.jianshu.com/" target="_blank" rel="external">http://http://www.jianshu.com/</a></td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center"><a href="http://localhost:8080/index.php?id=1234" target="_blank" rel="external">http://localhost:8080/index.php?id=1234</a></td>
<td style="text-align:center">/index.php?id=1234</td>
</tr>
<tr>
<td style="text-align:center"><a href="http://weibo.com/920507888/home" target="_blank" rel="external">http://weibo.com/920507888/home</a></td>
<td style="text-align:center">/home</td>
</tr>
</tbody>
</table>
<p>最长使用的属性是：</p>
<p>　　1. URL, 即http访问的地址</p>
<p>　　2. request method, 报文的请求方式</p>
<p>　　3. status code, 状态码以及状态短语</p>
<p>　　4. Accept Encoding, 内容编码</p>
<p>　　5. Connection, 连接方式</p>
<p>　　6. Cookie, 添加的cookie内容</p>
<p>　　7. Host, 目标主机</p>
<p>　　8. User-Agent, 客户端浏览器的相关信息</p>
<p>　　9. Set-Cookie, 指定想要在Cookie中保存的内容</p>
<h6 id="响应报文格式："><a href="#响应报文格式：" class="headerlink" title="响应报文格式："></a><strong><font color="#FF7256">响应报文格式：</font></strong></h6><p><img src="http://storage1.imgchr.com/images/19c2d6.png" alt="enter image description here"></p>
<p>在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。</p>
<h6 id="Header"><a href="#Header" class="headerlink" title="Header"></a><strong><font color="#FF7256">Header</font></strong></h6><p> <strong><font color="#FF7256">HTTP 首部字段结构：</font></strong></p>
<p>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“：” 分隔。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">首部字段名: 字段值</div></pre></td></tr></table></figure></p>
<p>例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Type</span>: text/html</div></pre></td></tr></table></figure></p>
<p>就以上述示例来看，首部字段名为 Content-Type，字符串 text/html 是字段值。</p>
<p>另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Keep-Alive</span>: timeout=15, max=100</div></pre></td></tr></table></figure></p>
<p>若HTTP首部字段重复了会如何？当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？</p>
<blockquote>
<p><strong><font color="#FF7256">这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。</font></strong></p>
</blockquote>
<p>Header可用于传递一些附加信息，格式： 键（Key）: 值（Value），注意冒号后面有一个空格！如：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Length</span>: 1024</div><div class="line"><span class="attribute">Content-Type</span>: text/plain</div></pre></td></tr></table></figure></p>
<p> <strong><font color="#FF7256">4种 HTTP 首部字段类型</font></strong></p>
<p>HTTP 首部字段根据实际用途被分为以下 4 种类型：</p>
<p><strong><font color="#FF7256">通用首部字段（General Header Fields）</font></strong></p>
<p>请求报文和响应报文两方都会使用的首部。</p>
<p><strong><font color="#FF7256">请求首部字段（Request Header Fields）</font></strong></p>
<p>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p>
<p><strong><font color="#FF7256">响应首部字段（Response Header Fields）</font></strong></p>
<p>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p>
<p><strong><font color="#FF7256">实体首部字段（Entity Header Fields）</font></strong></p>
<p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p>
<p> <strong><font color="#FF7256">通用Header字段</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">控制缓存的行为</td>
</tr>
<tr>
<td style="text-align:center">Connection</td>
<td style="text-align:center">逐跳首部、连接的管理</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">创建报文的日期时间</td>
</tr>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">报文指令</td>
</tr>
<tr>
<td style="text-align:center">Trailer</td>
<td style="text-align:center">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:center">Transfer-Encoding</td>
<td style="text-align:center">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td style="text-align:center">Upgrade</td>
<td style="text-align:center">升级为其他协议</td>
</tr>
<tr>
<td style="text-align:center">Via</td>
<td style="text-align:center">代理服务器的相关信息</td>
</tr>
<tr>
<td style="text-align:center">Warning</td>
<td style="text-align:center">错误通知</td>
</tr>
</tbody>
</table>
<p> <strong><font color="#FF7256">请求Header字段</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept</td>
<td style="text-align:center">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Accept-Charset</td>
<td style="text-align:center">优先的字符集</td>
</tr>
<tr>
<td style="text-align:center">Accept-Encoding</td>
<td style="text-align:center">优先的内容编码</td>
</tr>
<tr>
<td style="text-align:center">Accept-Language</td>
<td style="text-align:center">优先的语言（自然语言）</td>
</tr>
<tr>
<td style="text-align:center">Authorization    Web</td>
<td style="text-align:center">认证信息</td>
</tr>
<tr>
<td style="text-align:center">Expect</td>
<td style="text-align:center">期待服务器的特定行为</td>
</tr>
<tr>
<td style="text-align:center">From</td>
<td style="text-align:center">用户的电子邮箱地址</td>
</tr>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center">请求资源所在服务器</td>
</tr>
<tr>
<td style="text-align:center">If-Match</td>
<td style="text-align:center">比较实体标记（ETag）</td>
</tr>
<tr>
<td style="text-align:center">If-Modified-Since</td>
<td style="text-align:center">比较资源的更新时间</td>
</tr>
<tr>
<td style="text-align:center">If-None-Match</td>
<td style="text-align:center">比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td style="text-align:center">If-Range</td>
<td style="text-align:center">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td style="text-align:center">If-Unmodified-Since</td>
<td style="text-align:center">比较资源的更新时间（与If-Modified-Since相反）</td>
</tr>
<tr>
<td style="text-align:center">Max-Forwards</td>
<td style="text-align:center">最大传输逐跳数</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authorization</td>
<td style="text-align:center">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:center">Range</td>
<td style="text-align:center">实体的字节范围请求</td>
</tr>
<tr>
<td style="text-align:center">Referer</td>
<td style="text-align:center">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td style="text-align:center">TE</td>
<td style="text-align:center">传输编码的优先级</td>
</tr>
<tr>
<td style="text-align:center">User-Agent</td>
<td style="text-align:center">HTTP 客户端程序的信息</td>
</tr>
</tbody>
</table>
<p> <strong><font color="#FF7256">响应首部字段</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept-Ranges</td>
<td style="text-align:center">是否接受字节范围请求</td>
</tr>
<tr>
<td style="text-align:center">Age</td>
<td style="text-align:center">推算资源创建经过时间</td>
</tr>
<tr>
<td style="text-align:center">ETag</td>
<td style="text-align:center">资源的匹配信息</td>
</tr>
<tr>
<td style="text-align:center">Location</td>
<td style="text-align:center">令客户端重定向至指定URI</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authenticate</td>
<td style="text-align:center">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:center">Retry-After</td>
<td style="text-align:center">对再次发起请求的时机要求</td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center">HTTP服务器的安装信息</td>
</tr>
<tr>
<td style="text-align:center">Vary</td>
<td style="text-align:center">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td style="text-align:center">WWW-Authenticate</td>
<td style="text-align:center">服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<p><strong><font color="#FF7256">实体首部字段</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Allow</td>
<td style="text-align:center">资源可支持的HTTP方法</td>
</tr>
<tr>
<td style="text-align:center">Content-Encoding</td>
<td style="text-align:center">实体主体适用的编码方式</td>
</tr>
<tr>
<td style="text-align:center">Content-Language</td>
<td style="text-align:center">实体主体的自然语言</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td style="text-align:center">Content-Location</td>
<td style="text-align:center">替代对应资源的URI</td>
</tr>
<tr>
<td style="text-align:center">Content-MD5</td>
<td style="text-align:center">实体主体的报文摘要</td>
</tr>
<tr>
<td style="text-align:center">Content-Range</td>
<td style="text-align:center">实体主体的位置范围</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">实体主体的媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center">实体主体过期的日期时间</td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center">资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<p><strong><font color="#FF7256">非 HTTP/1.1 首部字段</font></strong></p>
<p>在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高。</p>
<p>这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。</p>
<p><strong><font color="#FF7256">End-to-end 首部和 Hop-by-hop 首部</font></strong></p>
<p>HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型。</p>
<p><strong><font color="#FF7256">端到端首部（End-to-end Header）</font></strong></p>
<p>分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p>
<p><strong><font color="#FF7256">逐跳首部（Hop-by-hop Header）</font></strong></p>
<p>分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。</p>
<p>下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外，其他所有字段都属于端到端首部。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection，Keep-Alive，Proxy-Authenticate，Proxy-Authorization，Trailer，TE，Transfer-Encoding，Upgrade</span></div></pre></td></tr></table></figure></p>
<h6 id="通用首部字段（HTTP-1-1）"><a href="#通用首部字段（HTTP-1-1）" class="headerlink" title=" 通用首部字段（HTTP/1.1）"></a><strong><font color="#FF7256"> 通用首部字段（HTTP/1.1）</font></strong></h6><p><strong><font color="#FF7256">A. Cache-Control</font></strong></p>
<p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p>
<p>指令的参数是可选的，多个指令之间通过“，”分隔。首部字段 Cache-Control 的指令可用于请求及响应时。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: private, max-age=0, no-cache</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">a. Cache-Control指令</font></strong></p>
<p><strong><font color="#FF7256">1. 缓存请求指令</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">no-cache</td>
<td style="text-align:center">无</td>
<td>强制向源服务器再次验证</td>
</tr>
<tr>
<td style="text-align:center">no-store</td>
<td style="text-align:center">无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td style="text-align:center">max-age = [ 秒]</td>
<td style="text-align:center">必需</td>
<td>响应的最大Age值</td>
</tr>
<tr>
<td style="text-align:center">max-stale( = [ 秒])</td>
<td style="text-align:center">可省略</td>
<td>接收已过期的响应</td>
</tr>
<tr>
<td style="text-align:center">min-fresh = [ 秒]</td>
<td style="text-align:center">必需</td>
<td>期望在指定时间内的响应仍有效</td>
</tr>
<tr>
<td style="text-align:center">no-transform</td>
<td style="text-align:center">无</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td style="text-align:center">only-if-cached</td>
<td style="text-align:center">无</td>
<td>从缓存获取资源</td>
</tr>
<tr>
<td style="text-align:center">cache-extension</td>
<td style="text-align:center">-</td>
<td>新指令标记（token）</td>
</tr>
</tbody>
</table>
<p><strong><font color="#FF7256">2. 缓存响应指令</font></strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">无</td>
<td>可向任意方提供响应的缓存</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">可省略</td>
<td>仅向特定用户返回响应</td>
</tr>
<tr>
<td style="text-align:center">no-cache</td>
<td style="text-align:center">可省略</td>
<td>缓存前必须先确认其有效性</td>
</tr>
<tr>
<td style="text-align:center">no-store</td>
<td style="text-align:center">无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td style="text-align:center">no-transform</td>
<td style="text-align:center">无</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td style="text-align:center">must-revalidate</td>
<td style="text-align:center">无</td>
<td>可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td style="text-align:center">proxy-revalidate</td>
<td style="text-align:center">无</td>
<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td style="text-align:center">max-age = [ 秒]</td>
<td style="text-align:center">必需</td>
<td>响应的最大Age值</td>
</tr>
<tr>
<td style="text-align:center">s-maxage = [ 秒]</td>
<td style="text-align:center">必需</td>
<td>公共缓存服务器响应的最大Age值</td>
</tr>
<tr>
<td style="text-align:center">cache-extension</td>
<td style="text-align:center">-</td>
<td>新指令标记（token）</td>
</tr>
</tbody>
</table>
<p> <strong><font color="#FF7256">b. 表示是否能缓存的指令</font></strong></p>
<p> <strong><font color="#FF7256">1. public 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: public</div></pre></td></tr></table></figure></p>
<p>当指定使用 public 指令时，则明确表明其他用户也可利用缓存。</p>
<p> <strong><font color="#FF7256">2. private 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: private</div></pre></td></tr></table></figure></p>
<p>当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。</p>
<p>缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p>
<p><strong><font color="#FF7256">3. no-cache 指令</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: no-cache</div></pre></td></tr></table></figure>
<p>使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。</p>
<p>客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。</p>
<p>如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: no-cache=Location</div></pre></td></tr></table></figure>
<p>由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。</p>
<p>控制可执行缓存的对象的指令</p>
<p><strong><font color="#FF7256">4. no-store 指令</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: no-store</div></pre></td></tr></table></figure>
<p>当使用 no-store 指令 1 时，暗示请求（和对应的响应）或响应中包含机密信息。</p>
<p>1 从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-not-serve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存，请读者注意区别理解。——译者注</p>
<p>因此，该指令规定缓存不能在本地存储请求或响应的任一部分。</p>
<p>指定缓存期限和认证的指令</p>
<p><strong><font color="#FF7256">5. s-maxage 指令</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: s-maxage=604800（单位 ：s秒）</div></pre></td></tr></table></figure>
<p>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器 （这里一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。</p>
<p>另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。</p>
<p><strong><font color="#FF7256">6. max-age 指令</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: max-age=604800（单位：秒）</div></pre></td></tr></table></figure>
<p>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。</p>
<p>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。</p>
<p>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略掉。</p>
<p><strong><font color="#FF7256">7. min-fresh 指令</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: min-fresh=60（单位：秒）</div></pre></td></tr></table></figure>
<p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。</p>
<p>比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响应返回了。</p>
<p><strong><font color="#FF7256">8. max-stale 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: max-stale=3600（单位：秒）</div></pre></td></tr></table></figure></p>
<p>使用 max-stale 可指示缓存资源，即使过期也照常接收。</p>
<p>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。</p>
<p><strong><font color="#FF7256">9. only-if-cached 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: only-if-cached</div></pre></td></tr></table></figure></p>
<p>使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。</p>
<p><strong><font color="#FF7256">10. must-revalidate 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: must-revalidate</div></pre></td></tr></table></figure></p>
<p>使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。</p>
<p>若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条504（Gateway Timeout）状态码。</p>
<p>另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale，也不会再有效果）。</p>
<p><strong><font color="#FF7256">11. proxy-revalidate 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: proxy-revalidate</div></pre></td></tr></table></figure></p>
<p>proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p>
<p><strong><font color="#FF7256">12. no-transform 指令</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: no-transform</div></pre></td></tr></table></figure></p>
<p>使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。</p>
<p>这样做可防止缓存或代理压缩图片等类似操作。</p>
<p><strong><font color="#FF7256">c. Cache-Control 扩展</font></strong></p>
<p><strong><font color="#FF7256">cache-extension token</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: private, community="UCI"</div></pre></td></tr></table></figure></p>
<p>通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。</p>
<p>如上例，Cache-Control 首部字段本身没有 community 这个指令。借助 extension tokens 实现了该指令的添加。如果缓存服务器不能理解 community 这个新指令，就会直接忽略。因此，extension tokens 仅对能理解它的缓存服务器来说是有意义的。</p>
<p><strong><font color="#FF7256">B. Connection</font></strong></p>
<p>Connection 首部字段具备如下两个作用：</p>
<ol>
<li>控制不再转发给代理的首部字段；</li>
<li>管理持久连接。</li>
</ol>
<p><strong><font color="#FF7256">a. 控制不再转发给代理的首部字段：</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection</span>: 不再转发的首部字段名</div></pre></td></tr></table></figure></p>
<p>在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。</p>
<p><strong><font color="#FF7256">b. 管理持久连接：</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection</span>: close</div></pre></td></tr></table></figure></p>
<p>HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection</span>: Keep-Alive</div></pre></td></tr></table></figure></p>
<p>HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。</p>
<p>如上图①所示，客户端发送请求给服务器时，服务器端会像上图②那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回响应。（后补图）</p>
<p><strong><font color="#FF7256">C. Date</font></strong></p>
<p>首部字段 Date 表明创建 HTTP 报文的日期和时间。</p>
<p>HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式，如下所示：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Date</span>: Tue, 03 Jul 2016 04:40:59 GMT</div></pre></td></tr></table></figure></p>
<p>之前的 HTTP 协议版本中使用在 RFC850 中定义的格式，如下所示：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Date</span>: Tue, 03-Jul-16 04:40:59 GMT</div></pre></td></tr></table></figure></p>
<p>除此之外，还有一种格式。它与 C 标准库内的 asctime() 函数的输出格式一致：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Date</span>: Tue Jul 03 04:40:59 2016</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">D. Pragma</font></strong></p>
<p>Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。</p>
<p>规范定义的形式唯一<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Pragma</span>: no-cache</div></pre></td></tr></table></figure></p>
<p>该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。</p>
<p>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cache-Control</span>: no-cache</div><div class="line"><span class="attribute">Pragma</span>: no-cache</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">E. Trailer</font></strong></p>
<p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Tue, 03 Jul 2016 04:40:56 GMT</div><div class="line">Content-Type: text/html</div><div class="line">...</div><div class="line">Transfer-Encoding: chunked</div><div class="line">Trailer: Expires</div><div class="line"></div><div class="line">...(报文主体)...</div><div class="line">0</div><div class="line">Expires: Tue, 8 Sep 2016 23:59:59 GMT</div></pre></td></tr></table></figure></p>
<p>以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后（分块长度 0 之后）出现了首部字段 Expires。</p>
<p><strong><font color="#FF7256">F. Transfer-Encoding</font></strong></p>
<p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。</p>
<p>HTTP/1.1 的传输编码方式仅对分块传输编码有效。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">200</span> OK</div><div class="line"><span class="attribute">Date</span>: Tue, 03 Jul 2016 04:40:56 GMT</div><div class="line"><span class="attribute">Cache-Control</span>: public, max-age=604800</div><div class="line"><span class="attribute">Content-Type</span>: text/javascript; charset=utf-8</div><div class="line"><span class="attribute">Expires</span>: Tue, 10 Jul 2012 04:40:56 GMT</div><div class="line"><span class="attribute">X-Frame-Options</span>: DENY</div><div class="line"><span class="attribute">X-XSS-Protection</span>: 1; mode=block</div><div class="line"><span class="attribute">Content-Encoding</span>: gzip</div><div class="line"><span class="attribute">Transfer-Encoding</span>: chunked</div><div class="line"><span class="attribute">Connection</span>: keep-alive</div><div class="line"></div><div class="line"><span class="undefined">cf0    ←16进制(10进制为3312)</span></div><div class="line"></div><div class="line">...3312字节分块数据...</div><div class="line"></div><div class="line">392    ←16进制(10进制为914)</div><div class="line"></div><div class="line">...914字节分块数据...</div><div class="line"></div><div class="line">0</div></pre></td></tr></table></figure></p>
<p>以上用例中，正如在首部字段 Transfer-Encoding 中指定的那样，有效使用分块传输编码，且分别被分成 3312 字节和 914 字节大小的分块数据。</p>
<p><strong><font color="#FF7256">G. Upgrade</font></strong></p>
<p>首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p>
<p><img src="http://storage1.imgchr.com/images/upgrade.png" alt="enter image description here"></p>
<p>上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务器之间。因此，使用首部字段 Upgrade 时，还需要额外指定 Connection:Upgrade。</p>
<p>对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。</p>
<p><strong><font color="#FF7256">H. Via</font></strong></p>
<p>使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。</p>
<p>报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。</p>
<p>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。</p>
<p><img src="http://storage1.imgchr.com/images/Via.png" alt="enter image description here"></p>
<p>上图用例中，在经过代理服务器 A 时，Via 首部附加了“1.0 gw.hackr.jp (Squid/3.1)”这样的字符串值。行头的 1.0 是指接收请求的服务器上应用的 HTTP 协议版本。接下来经过代理服务器 B 时亦是如此，在 Via 首部附加服务器信息，也可增加 1 个新的 Via 首部写入服务器信息。</p>
<p>Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使用。比如，代理服务器接收到由 TRACE 方法发送过来的请求（其中 Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况下，代理服务器会将自身的信息附加到 Via 首部后，返回该请求的响应。</p>
<p><strong><font color="#FF7256">I. Warning</font></strong></p>
<p>HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Warning</span>: 113 gw.hackr.jp:8080 "Heuristic expiration" Tue, 03 Jul 2012 05:09:44 GMT</div></pre></td></tr></table></figure></p>
<p>Warning 首部的格式如下。最后的日期时间部分可省略。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Warning</span>: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])</div></pre></td></tr></table></figure></p>
<p>HTTP/1.1 中定义了 7 种警告。警告码对应的警告内容仅推荐参考。另外，警告码具备扩展性，今后有可能追加新的警告码。</p>
<p>HTTP/1.1 警告码如下图：</p>
<table>
<thead>
<tr>
<th style="text-align:center">警告码</th>
<th style="text-align:center">警告内容</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">110</td>
<td style="text-align:center">Response is stale （响应已过期）</td>
<td style="text-align:center">代理返回已过期的资源</td>
</tr>
<tr>
<td style="text-align:center">111</td>
<td style="text-align:center">Revalidation failed（再验证失败）</td>
<td style="text-align:center">代理再验证资源有效性时失败 （服务器无法到达等原因）</td>
</tr>
<tr>
<td style="text-align:center">112</td>
<td style="text-align:center">Disconnection operation（断开连接操作）</td>
<td style="text-align:center">代理与互联网连接被故意切断</td>
</tr>
<tr>
<td style="text-align:center">113</td>
<td style="text-align:center">Heuristic expiration（试探性过期）</td>
<td style="text-align:center">响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）</td>
</tr>
<tr>
<td style="text-align:center">199</td>
<td style="text-align:center">Miscellaneous warning（杂项警告）</td>
<td style="text-align:center">任意的警告内容</td>
</tr>
<tr>
<td style="text-align:center">214</td>
<td style="text-align:center">Transformation applied（使用了转换）</td>
<td style="text-align:center">代理对内容编码或媒体类型等执行了某些处理时</td>
</tr>
<tr>
<td style="text-align:center">299</td>
<td style="text-align:center">Miscellaneous persistent warning（持久杂项警告）</td>
<td style="text-align:center">任意的警告内容</td>
</tr>
</tbody>
</table>
<h6 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a><strong><font color="#FF7256">请求首部字段</font></strong></h6><p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p>
<p><strong><font color="#FF7256">A. Accept</font></strong></p>
<p><img src="http://storage1.imgchr.com/images/Accept.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div></pre></td></tr></table></figure></p>
<p>上述表示览器支持的 MIME 类型分别是 text/html、application/xhtml+xml、application/xml 和 <em>/</em>，优先顺序是它们从左到右的排列顺序。</p>
<p><strong><font color="#FF7256">详解：</font></strong></p>
<p>　　Accept表示浏览器支持的 MIME 类型；<br>　　<br>　　MIME的英文全称是 Multipurpose Internet Mail Extensions（多功能 Internet 邮件扩充服务），它是一种多用途网际邮件扩充协议，在1992年最早应用于电子邮件系统，但后来也应用到浏览器。<br>　　<br>　　text/html,application/xhtml+xml,application/xml 都是 MIME 类型，也可以称为媒体类型和内容类型，斜杠前面的是 type（类型），斜杠后面的是 subtype（子类型）；type 指定大的范围，subtype 是 type 中范围更明确的类型，即大类中的小类。<br>　　<br>　　Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；<br>　　<br>　　text/html表示 html 文档；<br>　　<br>　　Application：用于传输应用程序数据或者二进制数据；<br>　　<br>　　application/xhtml+xml表示 xhtml 文档；<br>　　<br>　　application/xml表示 xml 文档。</p>
<p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。</p>
<p><strong><font color="#FF7256">文本文件</font></strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">text/plain，text/html，text/css ...</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">application/xhtml+xml, application/xml ...</div></pre></td></tr></table></figure>
<p><strong><font color="#FF7256">图片文件</font></strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">image/jpeg, image/gif, image/png ...</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">视频文件</font></strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">video/mpeg, video/quicktime，meaudio/mp4，video/mp4 ...</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">应用程序使用的二进制文件</font></strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">application/octet-stream, application/zip ...</div></pre></td></tr></table></figure>
<p>比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定 image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。</p>
<p>若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示<strong><font color="#FF7256">权重值</font></strong> ，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。</p>
<p><strong><font color="#FF7256">权重值</font></strong>原文是“品質係数”。在 RFC2616 定义中，此处的 q 是指 qvalue，即 quality factor。直译的话就是质量数，但经过综合考虑理解记忆的便利性后，似乎采用权重值更为稳妥。</p>
<p>当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。</p>
<p><strong><font color="#FF7256">B. Accept-Charset</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Charset</span>: GB2312,utf-8;q=0.7,*;q=0.7</div></pre></td></tr></table></figure></p>
<p>上述表示浏览器支持的字符编码分别是 GB2312、utf-8 和任意字符，优先顺序是 GB2312、utf-8、*。</p>
<p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。</p>
<p>该首部字段应用于内容协商机制的服务器驱动协商。</p>
<p><strong><font color="#FF7256">详解：</font></strong></p>
<p>　　Accept-Charset告诉 Web 服务器，浏览器可以接受哪些字符编码；<br>　　<br>　　GB2312是中国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，又称GB0，由中国国家标准总局发布，1981年5月1日实施。GB2312 编码通行于中国大陆；新加坡等地也采用此编码。<br>　　<br>　　utf-8是 Unicode 的一种变长字符编码又称万国码，由 Ken Thompson 于1992年创建，现在已经标准化为 RFC 3629。<br>　　<br>　　<strong><font color="#FF7256">* </font></strong>表示任意字符编码，虽然 q 都是等于 0.7，但明确指定的 GB2312,utf-8 比 * 具有更高的优先级。</p>
<p><strong><font color="#FF7256">C. Accept-Encoding</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</div></pre></td></tr></table></figure></p>
<p>上述表示浏览器支持的压缩编码是 gzip 和 deflate。</p>
<p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。</p>
<p><strong><font color="#FF7256">详解：</font></strong></p>
<p>　　Accept-Encoding表示浏览器有能力解码的编码类型；<br>　　<br>　　gzip是 GNU zip 的缩写，它是一个 GNU 自由软件的文件压缩程序，也经常用来表示 gzip 这种文件格式。<br>　　　　<br>　　deflate是同时使用了 LZ77 算法与哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。<br>　　<br><strong><font color="#FF7256">gzip</font></strong></p>
<p>由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，通称 CRC）。</p>
<p><strong><font color="#FF7256">compress</font></strong></p>
<p>由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel-Ziv-Welch 算法（LZW）。</p>
<p><strong><font color="#FF7256">deflate</font></strong></p>
<p>组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式。</p>
<p><strong><font color="#FF7256">identity</font></strong></p>
<p>不执行压缩或不会变化的默认编码格式。</p>
<p><strong><font color="#FF7256">D. Accept-Language</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Language</span>: zh-cn,zh;q=0.7,en-us,en;q=0.3</div></pre></td></tr></table></figure></p>
<p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。</p>
<p>和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在上述图例中，客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Language</span>: zh-cn,zh;q=0.5</div></pre></td></tr></table></figure>
<p>上述表示浏览器支持的语言分别是中文和简体中文，优先支持简体中文。<br>　　<br>　　<strong><font color="#FF7256">详解：</font></strong><br>　　<br>　　Accept-Language表示浏览器所支持的语言类型；<br>　　<br>　　zh-cn表示简体中文；zh 表示中文；<br>　　<br>　　q是权重系数，范围 0 =&lt; q &lt;= 1，q 值越大，请求越倾向于获得其“;”之前的类型表示的内容，若没有指定 q 值，则默认为1，若被赋值为0，则用于提醒服务器哪些是浏览器不接受的内容类型。</p>
<p><strong><font color="#FF7256">E. Authorization</font></strong></p>
<p><img src="http://storage1.imgchr.com/images/Authorization.png" alt="enter image description here"></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Authorization</span>: Basic dWVub3NlbjpwYXNzd29yZA==</div></pre></td></tr></table></figure>
<p>首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。读者也可参阅 RFC2616。</p>
<p><strong><font color="#FF7256">F. Expect</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Expect</span>: 100-continue</div></pre></td></tr></table></figure></p>
<p>客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。</p>
<p>客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规范只定义了 100-continue（状态码 100 Continue 之意）。</p>
<p>等待状态码 100 响应的客户端在发生请求时，需要指定 Expect:100-continue。</p>
<p><strong><font color="#FF7256">G. From</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">From：info@hackr.jp</span></div></pre></td></tr></table></figure></p>
<p>首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。</p>
<p><strong><font color="#FF7256">H. Host</font></strong></p>
<p><img src="http://storage1.imgchr.com/images/HOST.png" alt="enter image description here"></p>
<p>虚拟主机运行在同一个 IP 上，因此使用首部字段 Host 加以区分<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Host</span>: www.hackr.jp</div></pre></td></tr></table></figure></p>
<p>首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。</p>
<p>首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段 Host 必须存在的意义。</p>
<p>请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段 Host 来明确指出请求的主机名。若服务器未设定主机名，那直接发送一个空值即可。如下所示。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Host:</span></div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">I. If-Match</font></strong></p>
<p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p>
<p><img src="http://storage2.imgchr.com/If-Match.png" alt="enter image description here"></p>
<p>只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">If-Match</span>: "Orz-God"</div></pre></td></tr></table></figure>
<p>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。（请参照本章有关首部字段 ETag 的说明）</p>
<p>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。</p>
<p>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。</p>
<p><strong><font color="#FF7256">J. If-Modified-Since</font></strong></p>
<p><img src="http://storage1.imgchr.com/images/If-Modified-Since.png" alt="enter image description here"></p>
<p>如果在 If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">If-Modified-Since</span>: Thu, 25 Apr 2016 00:00:00 GMT</div></pre></td></tr></table></figure>
<p>首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。</p>
<p>If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。</p>
<p><strong><font color="#FF7256">K. If-None-Match</font></strong></p>
<p><img src="http://storage1.imgchr.com/images/if-no-match.png" alt="enter image description here"></p>
<p>只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与 If-Match 首部字段的作用相反</p>
<p>首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。</p>
<p>在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此，这与使用首部字段 If-Modified-Since 时有些类似。</p>
<p><strong><font color="#FF7256">L. If-Range</font></strong></p>
<p><img src="http://storage2.imgchr.com/If-Range.png" alt="enter image description here"></p>
<p>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</p>
<p><img src="http://storage1.imgchr.com/images/If-Range1.png" alt="enter image description here"></p>
<p>下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。</p>
<p> <strong><font color="#FF7256">M. If-Unmodified-Since</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">If-Unmodified-Since</span>: Thu, 03 Jul 2016 00:00:00 GMT</div></pre></td></tr></table></figure></p>
<p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。</p>
<p> <strong><font color="#FF7256">N. Max-Forwards</font></strong></p>
<p><img src="http://storage2.imgchr.com/Max-Forwards1.png" alt="enter image description here"></p>
<p>每次转发数值减 1，当数值变 0 时返回响应。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Max-Forwards</span>: 2</div></pre></td></tr></table></figure></p>
<p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。</p>
<p>使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中，如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。</p>
<p>可以灵活使用首部字段 Max-Forwards，针对以上问题产生的原因展开调查。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。</p>
<p><img src="http://storage2.imgchr.com/Max-Forwards2.png" alt="enter image description here"></p>
<p>代理 B 到源服务器的请求失败了，但客户端不知道。</p>
<p> <strong><font color="#FF7256">O. Proxy-Authorization</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Proxy-Authorization</span>: Basic dGlwOjkpNLAGfFY5</div></pre></td></tr></table></figure></p>
<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。</p>
<p>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段Authorization 可起到相同作用。有关 HTTP 访问认证，后面的章节会作详尽阐述。</p>
<p> <strong><font color="#FF7256">P. Range</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Range</span>: bytes=5001-10000</div></pre></td></tr></table></figure></p>
<p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。</p>
<p>接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。</p>
<p><img src="http://storage1.imgchr.com/images/Max-Forwards3.png" alt="enter image description here"></p>
<p>由于未知原因，导致请求陷入代理之间的循环，但客户端不知道。</p>
<p> <strong><font color="#FF7256">Q. Referer</font></strong><br> <img src="http://storage2.imgchr.com/Referer.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Referer</span>: http://www.hackr.jp/index.htm</div></pre></td></tr></table></figure></p>
<p>首部字段 Referer 会告知服务器请求的原始资源的 URI。</p>
<p>客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。</p>
<p>因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。</p>
<p>另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直沿用这个错误的拼写。</p>
<p> <strong><font color="#FF7256">R. TE</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">TE</span>: gzip, deflate;q=0.5</div></pre></td></tr></table></figure></p>
<p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。</p>
<p>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">TE</span>: trailers</div></pre></td></tr></table></figure></p>
<p> <strong><font color="#FF7256">S. User-Agent</font></strong></p>
<p>User-Agent 用于传达浏览器的种类<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0)      Gecko/20100101 Firefox/13.0.1</div></pre></td></tr></table></figure></p>
<p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>
<p>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</p>
<h6 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a><strong><font color="#FF7256">响应首部字段</font></strong></h6><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p>
<p> <strong><font color="#FF7256">A. Accept-Ranges</font></strong></p>
<p>当不能处理范围请求时，Accept-Ranges: none<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Ranges</span>: bytes</div></pre></td></tr></table></figure></p>
<p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。</p>
<p>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。</p>
<p> <strong><font color="#FF7256">B. Age</font></strong><br> <img src="http://storage1.imgchr.com/images/AGE.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Age</span>: 600</div></pre></td></tr></table></figure></p>
<p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</p>
<p>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。</p>
<p> <strong><font color="#FF7256">C. ETag</font></strong><br> <img src="http://storage2.imgchr.com/ETag.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ETag</span>: "82e22293907ce725faf67773957acd12"</div></pre></td></tr></table></figure></p>
<p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</p>
<p>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。</p>
<p><img src="http://storage1.imgchr.com/images/ETag1.png" alt="enter image description here"></p>
<p>资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览器访问 <a href="http://www.google.com/" target="_blank" rel="external">http://www.google.com/</a> 时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的 URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。</p>
<p> <strong><font color="#FF7256">强 ETag 值和弱 Tag 值：</font></strong></p>
<p>ETag 中有强 ETag 值和弱 ETag 值之分。</p>
<p> <strong><font color="#FF7256">强 ETag 值</font></strong></p>
<p>强 ETag 值，不论实体发生多么细微的变化都会改变其值。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ETag</span>: "usagi-orz"</div></pre></td></tr></table></figure></p>
<p> <strong><font color="#FF7256">弱 ETag 值</font></strong></p>
<p>弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ETag</span>: W/"usagi-orz"</div></pre></td></tr></table></figure></p>
<p> <strong><font color="#FF7256">D. Location</font></strong><br><img src="http://storage2.imgchr.com/location1.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Location</span>: http://www.usagidesign.jp/sample.html</div></pre></td></tr></table></figure></p>
<p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</p>
<p>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。</p>
<p>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>
<p> <strong><font color="#FF7256">E. Proxy-Authenticate</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Proxy-Authenticate</span>: Basic realm="Usagidesign Auth"</div></pre></td></tr></table></figure></p>
<p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。</p>
<p>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时，首部字段 WWW-Authorization 有着相同的作用。有关 HTTP 访问认证，后面的章节会再进行详尽阐述。</p>
<p> <strong><font color="#FF7256">F. Retry-After</font></strong><br> <img src="http://storage1.imgchr.com/images/retry.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">etry-After</span>: 120</div></pre></td></tr></table></figure></p>
<p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。</p>
<p>字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数。</p>
<p> <strong><font color="#FF7256">G. Server</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Server</span>: Apache/2.2.17 (Unix)</div></pre></td></tr></table></figure></p>
<p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Server</span>: Apache/2.2.6 (Unix) PHP/5.2.5</div></pre></td></tr></table></figure></p>
<p> <strong><font color="#FF7256">H. Vary</font></strong></p>
<p>当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Vary</span>: Accept-Language</div></pre></td></tr></table></figure></p>
<p>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</p>
<p>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</p>
<p> <strong><font color="#FF7256">I. WWW-Authenticate</font></strong><br> <img src="http://storage1.imgchr.com/images/Vary.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">WWW-Authenticate</span>: Basic realm="Usagidesign Auth"</div></pre></td></tr></table></figure></p>
<p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。</p>
<p>上述示例中，realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。有关该首部，请参阅本章之后的内容。</p>
<h6 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a><strong><font color="#FF7256">实体首部字段</font></strong></h6><p><strong><font color="#FF7256">A. Allow</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Allow</span>: GET, HEAD</div></pre></td></tr></table></figure>
<p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。</p>
<p><strong><font color="#FF7256">B. Content-Encoding </font></strong></p>
<p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</p>
<p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。四中压缩方式：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Encoding</span>: gzip</div><div class="line"><span class="attribute">Content-Encoding</span>: compress</div><div class="line"><span class="attribute">Content-Encoding</span>: deflate</div><div class="line"><span class="attribute">Content-Encoding</span>: identity</div></pre></td></tr></table></figure></p>
<p>客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">C. Content-Language</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Language</span>: zh-CN</div></pre></td></tr></table></figure>
<p>首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p>
<p><strong><font color="#FF7256">D. Content-Length</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Length</span>: 2048</div></pre></td></tr></table></figure>
<p>首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。由于实体主体大小的计算方法略微复杂，所以在此不再展开。</p>
<p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。</p>
<p>上面代码告诉浏览器，本次回应的长度是2048个字节，后面的字节就属于下一个回应了。</p>
<p>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p>
<p><strong><font color="#FF7256">E. Content-Location</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Location</span></div></pre></td></tr></table></figure></p>
<p>Content-Location: <a href="http://www.hackr.jp/index-ja.html" target="_blank" rel="external">http://www.hackr.jp/index-ja.html</a><br>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p>
<p>比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段 Content-Location 内会写明 URI。（访问 <a href="http://www.hackr.jp/" target="_blank" rel="external">http://www.hackr.jp/</a> 返回的对象却是 <a href="http://www.hackr.jp/index-ja.html" target="_blank" rel="external">http://www.hackr.jp/index-ja.html</a> 等类似情况）</p>
<p><strong><font color="#FF7256">F. Content-MD5</font></strong><br><img src="http://storage2.imgchr.com/md5.png" alt="enter image description here"><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-MD5</span>: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</div></pre></td></tr></table></figure></p>
<p>客户端会对接收的报文主体执行相同的 MD5 算法，然后与首部字段 Content-MD5 的字段值比较</p>
<p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p>
<p>对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编码后将结果写入 Content-MD5 字段值。由于 HTTP 首部无法记录二进制值，所以要通过 Base64 编码处理。为确保报文的有效性，作为接收方的客户端会对报文主体再执行一次相同的 MD5 算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。</p>
<p>采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味着 Content-MD5 也可重新计算然后被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过的。</p>
<p><strong><font color="#FF7256">G. Content-Range</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Range</span>: bytes 5001-10000/10000</div></pre></td></tr></table></figure></p>
<p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p>
<p><strong><font color="#FF7256">H. Content-Type ：</font></strong></p>
<p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。</p>
<p> <strong><font color="#FF7256">常见的Content-Type字段的值：</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">text/plain，text/html，text/css</span></div></pre></td></tr></table></figure>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">image/jpeg，image/png，image/svg+xml</span></div></pre></td></tr></table></figure>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">audio/mp4，video/mp4</span></div></pre></td></tr></table></figure>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">application/javascript，application/pdf，application/zip，application/atom+xml</span></div></pre></td></tr></table></figure>
<p>这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。</p>
<p>除了预定义的类型，厂商也可以自定义类型。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">application/vnd.debian.binary-package</span></div></pre></td></tr></table></figure>
<p>上面的类型表明，发送的是Debian系统的二进制数据包。</p>
<p>MIME type还可以在尾部使用分号，添加参数。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</div></pre></td></tr></table></figure></p>
<p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p>
<p>客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Accept</span>: */*</div></pre></td></tr></table></figure>
<p>上面代码中，客户端声明自己可以接受任何格式的数据。</p>
<p>MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">I. Expires</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Expires</span>: Wed, 04 Jul 2016 08:00:00 GMT</div></pre></td></tr></table></figure></p>
<p>首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。</p>
<p>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。</p>
<p>但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。</p>
<p><strong><font color="#FF7256">J. Last-Modified</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Last-Modified</span>: Wed, 23 May 2016 10:05:24 GMT</div></pre></td></tr></table></figure>
<p>首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。</p>
<h6 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a><strong><font color="#FF7256">为 Cookie 服务的首部字段</font></strong></h6><p>管理服务器与客户端之间状态的 Cookie，虽然没有被编入标准化 HTTP/1.1 的 RFC2616 中，但在 Web 网站方面得到了广泛的应用。</p>
<p>Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。</p>
<p>调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他 Web 站点和攻击者的攻击而泄露。</p>
<p>Cookie 的规格标准文档有以下 4 种。</p>
<p><strong><font color="#FF7256">由网景公司颁布的规格标准</font></strong></p>
<p>网景通信公司设计并开发了 Cookie，并制定相关的规格标准。1994 年前后，Cookie 正式应用在网景浏览器中。目前最为普及的 Cookie 方式也是以此为基准的。</p>
<p><strong><font color="#FF7256">RFC2109</font></strong></p>
<p>某企业尝试以独立技术对 Cookie 规格进行标准化统筹。原本的意图是想和网景公司制定的标准交互应用，可惜发生了微妙的差异。现在该标准已淡出了人们的视线。</p>
<p><strong><font color="#FF7256">RFC2965</font></strong></p>
<p>为终结 Internet Explorer 浏览器与 Netscape Navigator 的标准差异而导致的浏览器战争，RFC2965 内定义了新的 HTTP 首部 Set-Cookie2 和 Cookie2。可事实上，它们几乎没怎么投入使用。</p>
<p><strong><font color="#FF7256">RFC6265</font></strong></p>
<p>将网景公司制定的标准作为业界事实标准（De facto standard），重新定义 Cookie 标准后的产物。</p>
<p>目前使用最广泛的 Cookie 标准却不是 RFC 中定义的任何一个。而是在网景公司制定的标准上进行扩展后的产物。</p>
<p>本节接下来就对目前使用最为广泛普及的标准进行说明。</p>
<p>下面的表格内列举了与 Cookie 有关的首部字段。</p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Set-Cookie</td>
<td style="text-align:center">开始状态管理所使用的Cookie信息</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">Cookie</td>
<td style="text-align:center">服务器接收到的Cookie信息</td>
<td style="text-align:center">请求首部字段</td>
</tr>
</tbody>
</table>
<p><strong><font color="#FF7256">A. Set-Cookie</font></strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Set-Cookie</span>: status=enable; expires=Tue, 05 Jul 2016 07:26:31 GMT; path=/; domain=.hackr.jp;</div></pre></td></tr></table></figure>
<p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</p>
<p>下面的表格列举了 Set-Cookie 的字段值。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NAME=VALUE</td>
<td style="text-align:center">赋予 Cookie 的名称和其值（必需项）</td>
</tr>
<tr>
<td style="text-align:center">expires=DATE</td>
<td style="text-align:center">Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td style="text-align:center">path=PATH</td>
<td style="text-align:center">将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td style="text-align:center">domain=域名</td>
<td style="text-align:center">作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名）</td>
</tr>
<tr>
<td style="text-align:center">Secure</td>
<td style="text-align:center">仅在 HTTPS 安全通信时才会发送 Cookie</td>
</tr>
<tr>
<td style="text-align:center">HttpOnly</td>
<td style="text-align:center">加以限制，使 Cookie 不能被 JavaScript 脚本访问</td>
</tr>
</tbody>
</table>
<p><strong><font color="#FF7256">expires 属性</font></strong></p>
<p>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。</p>
<p>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。</p>
<p>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</p>
<p><strong><font color="#FF7256">path 属性</font></strong></p>
<p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。</p>
<p><strong><font color="#FF7256">domain 属性</font></strong></p>
<p>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除 example.com 以外，www.example.com 或 www2.example.com 等都可以发送 Cookie。</p>
<p>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。</p>
<p><strong><font color="#FF7256">secure 属性</font></strong></p>
<p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。</p>
<p>发送 Cookie 时，指定 secure 属性的方法如下所示。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Set-Cookie</span>: name=value; secure</div></pre></td></tr></table></figure>
<p>以上例子仅当在 <a href="https://www.example.com/（HTTPS）安全连接的情况下才会进行" target="_blank" rel="external">https://www.example.com/（HTTPS）安全连接的情况下才会进行</a> Cookie 的回收。也就是说，即使域名相同，<a href="http://www.example.com/（HTTP）也不会发生" target="_blank" rel="external">http://www.example.com/（HTTP）也不会发生</a> Cookie 回收行为。</p>
<p>当省略 secure 属性时，不论 HTTP 还是 HTTPS，都会对 Cookie 进行回收。</p>
<p><strong><font color="#FF7256">HttpOnly 属性</font></strong></p>
<p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</p>
<p>发送指定 HttpOnly 属性的 Cookie 的方法如下所示。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Set-Cookie</span>: name=value; HttpOnly</div></pre></td></tr></table></figure>
<p>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。</p>
<p>虽然是独立的扩展功能，但 Internet Explorer 6 SP1 以上版本等当下的主流浏览器都已经支持该扩展了。另外顺带一提，该扩展并非是为了防止 XSS 而开发的。</p>
<p><strong><font color="#FF7256">B. Cookie</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Cookie</span>: status=enable</div></pre></td></tr></table></figure></p>
<p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p>
<h6 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a><strong><font color="#FF7256">其他首部字段</font></strong></h6><p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。</p>
<p>接下来，我们就一些最为常用的首部字段进行说明。</p>
<p><strong><font color="#FF7256">X-Frame-Options</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">X-Frame-Options</span>: DENY</div></pre></td></tr></table></figure></p>
<p>首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</p>
<p>首部字段 X-Frame-Options 有以下两个可指定的字段值。</p>
<blockquote>
<p><strong><font color="#FF7256">DENY ：拒绝</font></strong><br><strong><font color="#FF7256">SAMEORIGIN ：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 <a href="http://hackr.jp/sample.html" target="_blank" rel="external">http://hackr.jp/sample.html</a> 页面为 SAMEORIGIN 时，那么 hackr.jp 上所有页面的 frame 都被允许可加载该页面，而 example.com 等其他域名的页面就不行了）</font></strong></p>
</blockquote>
<p>支持该首部字段的浏览器有：Internet Explorer 8、Firefox 3.6.9+、Chrome 4.1.249.1042+、Safari 4+ 和 Opera 10.50+ 等。现在主流的浏览器都已经支持。</p>
<p>能在所有的 Web 服务器端预先设定好 X-Frame-Options 字段值是最理想的状态。</p>
<p>对 apache2.conf 的配置实例<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">&lt;IfModule mod_headers.c&gt;</span></div><div class="line">   <span class="attribute"><span class="nomarkup">Header</span></span> append X-FRAME-OPTIONS <span class="string">"SAMEORIGIN"</span></div><div class="line"><span class="section">&lt;/IfModule&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">X-XSS-Protection</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">X-XSS-Protection</span>: 1</div></pre></td></tr></table></figure></p>
<p>首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。</p>
<p>首部字段 X-XSS-Protection 可指定的字段值如下。</p>
<p><strong><font color="#FF7256">0 ：将 XSS 过滤设置成无效状态</font></strong><br><strong><font color="#FF7256">1 ：将 XSS 过滤设置成有效状态</font></strong></p>
<p><strong><font color="#FF7256">DNT</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">DNT</span>: 1</div></pre></td></tr></table></figure></p>
<p>首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。</p>
<p>首部字段 DNT 可指定的字段值如下。</p>
<p><strong><font color="#FF7256">1 ：拒绝被追踪</font></strong><br><strong><font color="#FF7256">0 ：同意被追踪由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT 做对应的支持。</font></strong></p>
<p><strong><font color="#FF7256">P3P</font></strong><br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">P3P</span>: CP="CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND UNI COM NAV INT"</div></pre></td></tr></table></figure></p>
<p>首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</p>
<p>要进行 P3P 的设定，需按以下操作步骤进行:</p>
<ol>
<li><p>创建 P3P 隐私</p>
</li>
<li><p>创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml</p>
</li>
<li><p>从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</p>
</li>
</ol>
<p>有关 P3P 的详细规范标准请参看下方链接。</p>
<p><a href="http://www.w3.org/TR/P3P/" target="_blank" rel="external">The Platform for Privacy Preferences 1.0（P3P1.0）Specification</a></p>
<p>协议中对 X- 前缀的废除：</p>
<blockquote>
<p><strong><font color="#FF7256">在 HTTP 等多种协议中，通过给非标准参数加上前缀 X-，来区别于标准参数，并使那些非标准的参数作为扩展变成可能。但是这种简单粗暴的做法有百害而无一益，因此在“RFC 6648 - Deprecating the “X-“ Prefix and Similar Constructs in Application Protocols”中提议停止该做法。然而，对已经在使用中的 X- 前缀来说，不应该要求其变更。</font></strong></p>
</blockquote>
<p><strong><font color="#FF7256">Weakness：</font></strong></p>
<p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>
<p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p>
<p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection</span>: keep-alive</div></pre></td></tr></table></figure></p>
<p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。这样，一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
<h5 id="HTTP-1-1："><a href="#HTTP-1-1：" class="headerlink" title="HTTP/1.1："></a><strong><font color="#FF7256">HTTP/1.1：</font></strong></h5><p>它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。当前浏览器客户端与服务器端建立连接之后，可以在一次连接中发送多次请求（基本都使用1.1）。请求一次资源就会出现一次请求，比如三张图片，就有三次请求，如果图片是一样 的就只有一次请求。</p>
<h6 id="持久连接："><a href="#持久连接：" class="headerlink" title="持久连接："></a><strong><font color="#FF7256">持久连接：</font></strong></h6><p>HTTP/1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<font color="#FF7256">Connection: keep-alive</font>。</p>
<p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Connection</span>: close</div></pre></td></tr></table></figure></p>
<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>
<h6 id="管道机制："><a href="#管道机制：" class="headerlink" title="管道机制："></a><strong><font color="#FF7256">管道机制：</font></strong></h6><p>HTTP/1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h6 id="分块传输编码："><a href="#分块传输编码：" class="headerlink" title="分块传输编码："></a><strong><font color="#FF7256">分块传输编码：</font></strong></h6><p>使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>
<p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p>
<p>因此，1.1版规定可以不使用Content-Length字段，而使用“分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Transfer-Encoding</span>: chunked</div></pre></td></tr></table></figure></p>
<p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">200</span> OK</div><div class="line"><span class="attribute">Content-Type</span>: text/plain</div><div class="line"><span class="attribute">Transfer-Encoding</span>: chunked</div><div class="line"></div><div class="line"><span class="javascript"><span class="number">25</span></span></div><div class="line">This is the data <span class="keyword">in</span> the first chunk</div><div class="line"></div><div class="line"><span class="number">1</span>C</div><div class="line">and <span class="keyword">this</span> is the second one</div><div class="line"></div><div class="line"><span class="number">3</span></div><div class="line">con</div><div class="line"></div><div class="line"><span class="number">8</span></div><div class="line">sequence</div><div class="line"></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure></p>
<h6 id="其他功能："><a href="#其他功能：" class="headerlink" title="其他功能："></a><strong><font color="#FF7256">其他功能：</font></strong></h6><p>HTTP/1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p>
<p>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Host</span>: www.example.com</div></pre></td></tr></table></figure></p>
<p>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>
<h6 id="Weakness："><a href="#Weakness：" class="headerlink" title="Weakness："></a><strong><font color="#FF7256">Weakness：</font></strong></h6><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为“队头堵塞”（Head-of-line blocking）。</p>
<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>
<h5 id="SPDY协议："><a href="#SPDY协议：" class="headerlink" title="SPDY协议："></a><strong><font color="#FF7256">SPDY协议：</font></strong></h5><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p>
<p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。</p>
<p><strong><font color="#FF7256">SPDY 的设计与功能</font></strong> </p>
<p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。</p>
<p>SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、Cookie 以及 HTTP 报文等。</p>
<p><img src="http://storage2.imgchr.com/SPDY.png" alt="enter image description here"></p>
<p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p>
<p><strong><font color="#FF7256">1. 多路复用流</font></strong></p>
<p>通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。</p>
<p><strong><font color="#FF7256">2. 赋予请求优先级</font></strong></p>
<p>SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</p>
<p><strong><font color="#FF7256">3. 压缩 HTTP 首部</font></strong></p>
<p>压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。</p>
<p><strong><font color="#FF7256">4. 推送功能</font></strong></p>
<p>支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p>
<p><strong><font color="#FF7256">5. 服务器提示功能</font></strong></p>
<p>服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</p>
<p>希望使用 SPDY 时，Web 的内容端不必做什么特别改动，而 Web 浏览器及 Web 服务器都要为对应 SPDY 做出一定程度上的改动。有好几家 Web 浏览器已经针对 SPDY 做出了相应的调整。另外，Web 服务器也进行了实验性质的应用，但把该技术导入实际的 Web 网站却进展不佳。</p>
<p>因为 SPDY 基本上只是将单个域名（ IP 地址）的通信多路复用，所以当一个 Web 网站上使用多个域名下的资源，改善效果就会受到限制。</p>
<p>SPDY 的确是一种可有效消除 HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所导致。对 Web 本身的速度提升，还应该从其他可细致钻研的地方入手，比如改善 Web 内容的编写方式等。</p>
<h5 id="HTTP-2："><a href="#HTTP-2：" class="headerlink" title="HTTP/2："></a><strong><font color="#FF7256">HTTP/2：</font></strong></h5><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本，下一个新版本将是 HTTP/3。性能更快更强是肯定的，还针对移动端做了优化，WebSocket,全双工通信标准，客户端服务端互发。</p>
<p><strong><font color="#FF7256">HTTP/2.0 的特点</font></strong></p>
<p>HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验。由于基本上都会先通过 HTTP/1.1 与 TCP 连接，现在我们以下面的这些协议为基础，探讨一下它们的实现方法。</p>
<blockquote>
<p><strong><font color="#FF7256">SPDY、HTTP Speed ＋ Mobility、Network-Friendly HTTP Upgrade</font></strong></p>
</blockquote>
<p>HTTP Speed ＋ Mobility 由微软公司起草，是用于改善并提高移动端通信时的通信速度和性能的标准。它建立在 Google 公司提出的 SPDY 与 WebSocket 的基础之上。</p>
<p>Network-Friendly HTTP Upgrade 主要是在移动端通信时改善 HTTP 性能的标准。</p>
<p>HTTP/2.0 的 7 项技术及讨论</p>
<p>HTTP/2.0 围绕着主要的 7 项技术进行讨论，现阶段（2012 年 8 月 13 日），大都倾向于采用以下协议的技术。但是，讨论仍在持续，所以不能排除会发生重大改变的可能性。</p>
<table>
<thead>
<tr>
<th style="text-align:center">技术</th>
<th style="text-align:center">method</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">压缩</td>
<td style="text-align:center">SPDY、Friendly</td>
</tr>
<tr>
<td style="text-align:center">多路复用</td>
<td style="text-align:center">SPDY</td>
</tr>
<tr>
<td style="text-align:center">TLS 义务化</td>
<td style="text-align:center">Speed＋ Mobility</td>
</tr>
<tr>
<td style="text-align:center">协商</td>
<td style="text-align:center">Speed＋ Mobility，Friendly</td>
</tr>
<tr>
<td style="text-align:center">客户端拉曳（Client Pull）/服务器推送（Server Push）</td>
<td style="text-align:center">Speed＋ Mobility</td>
</tr>
<tr>
<td style="text-align:center">流量控制</td>
<td style="text-align:center">SPDY</td>
</tr>
<tr>
<td style="text-align:center">WebSocket</td>
<td style="text-align:center">Speed＋ Mobility</td>
</tr>
</tbody>
</table>
<p>注：HTTP Speed ＋ Mobility 简写为 Speed ＋ Mobility，Network-Friendly HTTP Upgrade 简写为 Friendly。</p>
<p><strong><font color="#FF7256">使用浏览器进行全双工通信的 WebSocket</font></strong></p>
<p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket 网络技术正是为解决这些问题而实现的一套新协议及 API。</p>
<p>当时筹划将 WebSocket 作为 HTML5 标准的一部分，而现在它却逐渐变成了独立的协议标准。WebSocket 通信协议在 2011 年 12 月 11 日，被 RFC 6455 - The WebSocket Protocol 定为标准。</p>
<p><strong><font color="#FF7256">WebSocket 的设计与功能</font></strong></p>
<p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。其中，WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。仍在开发中的 WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。</p>
<p><strong><font color="#FF7256">WebSocket 协议</font></strong></p>
<p>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。</p>
<p>由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p>
<p>下面我们列举一下 WebSocket 协议的主要特点。</p>
<p><strong><font color="#FF7256">推送功能</font></strong></p>
<p>支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p>
<p><strong><font color="#FF7256">减少通信量</font></strong></p>
<p>只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。</p>
<p>为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次“握手”（Handshaking）的步骤。</p>
<ol>
<li>握手·请求</li>
</ol>
<p>为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: server.example.com</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==</div><div class="line"><span class="attribute">Origin</span>: http://example.com</div><div class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat, superchat</div><div class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</div></pre></td></tr></table></figure></p>
<p>Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。Sec-WebSocket-Protocol 字段内记录使用的子协议。</p>
<p>子协议按 WebSocket 协议标准在连接分开使用时，定义那些连接的名称。</p>
<ol>
<li>握手·响应</li>
</ol>
<p>对于之前的请求，返回状态码 101 Switching Protocols 的响应。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Sec-WebSocket-Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</div><div class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat</div></pre></td></tr></table></figure></p>
<p>Sec-WebSocket-Accept 的字段值是由握手请求中的 Sec-WebSocket-Key 的字段值生成的。</p>
<p>成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p>
<p><img src="http://storage1.imgchr.com/images/WebSocket.png" alt="enter image description here"></p>
<p>WebSocket API</p>
<p>JavaScript 可调用“The WebSocket API”（<a href="http://www.w3.org/TR/websockets/，由" target="_blank" rel="external">http://www.w3.org/TR/websockets/，由</a> W3C 标准制定）内提供的 WebSocket 程序接口，以实现 WebSocket 协议下全双工通信。</p>
<p>以下为调用 WebSocket API，每 50ms 发送一次数据的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://game.example.com:12010/updates'</span>);</div><div class="line">socket.onopen = function () &#123;</div><div class="line">   setInterval(function() &#123;</div><div class="line">      <span class="keyword">if</span> (socket.bufferedAmount == <span class="number">0</span>)</div><div class="line">      socket.send(getUpdateData());</div><div class="line">   &#125;, <span class="number">50</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h6 id="二进制协议："><a href="#二进制协议：" class="headerlink" title="二进制协议："></a><strong><font color="#FF7256">二进制协议：</font></strong></h6><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p>
<p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<h6 id="多工："><a href="#多工：" class="headerlink" title="多工："></a><strong><font color="#FF7256">多工：</font></strong></h6><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>
<p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p>
<p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p>
<h6 id="数据流："><a href="#数据流：" class="headerlink" title="数据流："></a><strong><font color="#FF7256">数据流：</font></strong></h6><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p>
<p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p>
<p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
<h6 id="头信息压缩："><a href="#头信息压缩：" class="headerlink" title="头信息压缩："></a><strong><font color="#FF7256">头信息压缩：</font></strong></h6><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>
<p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
<h6 id="服务器推送："><a href="#服务器推送：" class="headerlink" title="服务器推送："></a><strong><font color="#FF7256">服务器推送：</font></strong></h6><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p>
<p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
<h3 id="二、HTTPS"><a href="#二、HTTPS" class="headerlink" title="二、HTTPS"></a><strong><font color="#FF7256">二、HTTPS</font></strong></h3><p><strong><font color="#FF7256">HTTPS和HTTP的区别：</font></strong></p>
<p>1.https协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
<ol>
<li><p>http是超文本传输协议，信息是明文传输；https 则是具有安全性的ssl加密传输协议。</p>
</li>
<li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
</li>
<li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
</li>
</ol>
<blockquote>
<p><strong><font color="#FF7256">HTTP + 加密 + 认证 + 完整性保护 =HTTPS</font></strong></p>
</blockquote>
<p><strong><font color="#FF7256">HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS</font></strong></p>
<p>如果在 HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。</p>
<p>另外，对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。</p>
<p>为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。</p>
<p>经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用 <a href="http://，而是改用" target="_blank" rel="external">http://，而是改用</a> <a href="https://。另外，当浏览器访问" target="_blank" rel="external">https://。另外，当浏览器访问</a> HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。</p>
<p><strong><font color="#FF7256">HTTPS 是身披 SSL 外壳的 HTTP</font></strong></p>
<p><img src="http://storage2.imgchr.com/HTTPS.png" alt="enter image description here"></p>
<p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。</p>
<p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p>
<p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。</p>
<p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p>
<p><strong><font color="#FF7256">相互交换密钥的公开密钥加密技术</font></strong></p>
<p>在对 SSL 进行讲解之前，我们先来了解一下加密方法。SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p>
<p>近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。</p>
<p>加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。</p>
<ol>
<li><strong><font color="#FF7256">共享密钥加密的困境</font></strong></li>
</ol>
<p>加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。</p>
<p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>
<ol>
<li><strong><font color="#FF7256">使用两把密钥的公开密钥加密</font></strong></li>
</ol>
<p>公开密钥加密方式很好地解决了共享密钥加密的困难。</p>
<p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p>
<p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p>
<p>另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。</p>
<ol>
<li><strong><font color="#FF7256">HTTPS 采用混合加密机制</font></strong></li>
</ol>
<p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p>
<p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p>
<ol>
<li><strong><font color="#FF7256">证明公开密钥正确性的证书</font></strong></li>
</ol>
<p>遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。</p>
<p>为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。</p>
<p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。威瑞信（VeriSign）就是其中一家非常有名的数字证书认证机构。我们来介绍一下数字证书认证机构的业务流程。首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。</p>
<p>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。</p>
<p>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。</p>
<p>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p>
<ol>
<li><strong><font color="#FF7256">可证明组织真实性的 EV SSL 证书</font></strong></li>
</ol>
<p>证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL 证书（Extended Validation SSL Certificate）。</p>
<p>EV SSL 证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的 Web 网站能够获得更高的认可度。</p>
<p>持有 EV SSL 证书的 Web 网站的浏览器地址栏处的背景色是绿色的，从视觉上就能一眼辨别出。而且在地址栏的左侧显示了 SSL 证书中记录的组织名称以及颁发证书的认证机构的名称。</p>
<p>上述机制的原意图是为了防止用户被钓鱼攻击（Phishing），但就效果上来讲，还得打一个问号。很多用户可能不了解 EV SSL 证书相关的知识，因此也不太会留意它。</p>
<ol>
<li><strong><font color="#FF7256">用以确认客户端的客户端证书</font></strong></li>
</ol>
<p>HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端，其作用跟服务器证书如出一辙。</p>
<p>但客户端证书仍存在几处问题点。其中的一个问题点是证书的获取及发布。</p>
<p>想获取证书时，用户得自行安装客户端证书。但由于客户端证书是要付费购买的，且每张证书对应到每位用户也就意味着需支付和用户数对等的费用。另外，要让知识层次不同的用户们自行安装证书，这件事本身也充满了各种挑战。</p>
<p>现状是，安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。</p>
<p>例如，银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入 ID 和密码，还会要求用户的客户端证书，以确认用户是否从特定的终端访问网银。</p>
<p>客户端证书存在的另一个问题点是，客户端证书毕竟只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性。也就是说，只要获得了安装有客户端证书的计算机的使用权限，也就意味着同时拥有了客户端证书的使用权限。</p>
<ol>
<li><strong><font color="#FF7256">认证机构信誉第一</font></strong></li>
</ol>
<p>SSL 机制中介入认证机构之所以可行，是因为建立在其信用绝对可靠这一大前提下的。然而，2011 年 7 月，荷兰的一家名叫 DigiNotar 的认证机构曾遭黑客不法入侵，颁布了 google.com 和 twitter.com 等网站的伪造证书事件。这一事件从根本上撼动了 SSL 的可信度。</p>
<p>因为伪造证书上有正规认证机构的数字签名，所以浏览器会判定该证书是正当的。当伪造的证书被用做服务器伪装之时，用户根本无法察觉到。</p>
<p>虽然存在可将证书无效化的证书吊销列表（Certificate Revocation List，CRL）机制，以及从客户端删除根证书颁发机构（Root Certificate Authority，RCA）的对策，但是距离生效还需要一段时间，而在这段时间内，到底会有多少用户的利益蒙受损失就不得而知了。</p>
<ol>
<li><strong><font color="#FF7256">由自认证机构颁发的证书称为自签名证书</font></strong></li>
</ol>
<p>如果使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用，似乎没什么帮助。</p>
<p>独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书。</p>
<p>浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。</p>
<h4 id="HTTPS-的安全通信机制"><a href="#HTTPS-的安全通信机制" class="headerlink" title="HTTPS 的安全通信机制"></a><strong><font color="#FF7256">HTTPS 的安全通信机制</font></strong></h4><p><img src="http://storage2.imgchr.com/HTTPSd4998.png" alt="enter image description here"></p>
<p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p>
<p>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p>
<p>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p>
<p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p>
<p>步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p>
<p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p>
<p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p>
<p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p>
<p>步骤 9： 服务器同样发送 Finished 报文。</p>
<p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p>
<p>步骤 11： 应用层协议通信，即发送 HTTP 响应。</p>
<p>步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p>
<p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p>
<blockquote>
<p><strong><font color="#FF7256">CBC 模式（Cipher Block Chaining）又名密码分组链接模式。在此模式下，将前一个明文块加密处理后和下一个明文块做 XOR 运算，使之重叠，然后再对运算结果做加密处理。对第一个明文块做加密时，要么使用前一段密文的最后一块，要么利用外部生成的初始向量（initial vector，IV）。</font></strong> </p>
</blockquote>
<h5 id="SL-和-TLS"><a href="#SL-和-TLS" class="headerlink" title="SL 和 TLS"></a><strong><font color="#FF7256">SL 和 TLS</font></strong></h5><p>HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security）这两个协议。</p>
<p>SSL 技术最初是由浏览器开发商网景通信公司率先倡导的，开发过 SSL3.0 之前的版本。目前主导权已转移到 IETF（Internet Engineering Task Force，Internet 工程任务组）的手中。</p>
<p>IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和 TLS1.2。TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。</p>
<p>由于 SSL1.0 协议在设计之初被发现出了问题，就没有实际投入使用。SSL2.0 也被发现存在问题，所以很多浏览器直接废除了该协议版本。</p>
<p><strong><font color="#FF7256">SSL (Secure Socket Layer，安全套接字层)：</font></strong> </p>
<p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本。</p>
<p>SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<p><strong><font color="#FF7256">TSL (Transport Layer Security，传输层安全协议)：</font></strong> </p>
<p>用于两个应用程序之间提供保密性和数据完整性。</p>
<p>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</p>
<p><strong><font color="#FF7256">SSL/TSL协议作用：</font></strong> </p>
<p>认证用户和服务器，确保数据发送到正确的客户机和服务器；<br>加密数据以防止数据中途被窃取；<br>维护数据的完整性，确保数据在传输过程中不被改变。</p>
<p><strong><font color="#FF7256">TSL比SSL的优势</font></strong> </p>
<p>对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。<br>增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。</p>
<p>改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。</p>
<p>一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。<br>特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。</p>
<p><strong><font color="#FF7256"> SSL、TSL的握手过程</font></strong></p>
<p>SSL与TSL握手整个过程如下图所示，下面会详细介绍每一步的具体内容：</p>
<p><img src="http://i2.buimg.com/567571/52da9cfd2c9ef658.png" alt="enter image description here"></p>
<p><strong><font color="#FF7256">客户端首次发出请求</font></strong> </p>
<p>由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的 Master Secret 。</p>
<p>客户端需要提供如下信息：</p>
<blockquote>
<p>支持的协议版本，比如TLS 1.0版<br>一个客户端生成的随机数，稍后用于生成”对话密钥”<br>支持的加密方法，比如RSA公钥加密<br>支持的压缩方法<br>服务端首次回应</p>
</blockquote>
<p>服务端在接收到客户端的Client Hello之后，服务端需要确定加密协议的版本，以及加密的算法，然后也生成一个随机数，以及将自己的证书发送给客户端一并发送给客户端，这里的随机数是整个过程的第二个随机数。</p>
<p>服务端需要提供的信息：</p>
<blockquote>
<p>协议的版本<br>加密的算法<br>随机数<br>服务器证书</p>
</blockquote>
<p><strong><font color="#FF7256">客户端再次回应</font></strong> </p>
<p>客户端首先会对服务器下发的证书进行验证，验证通过之后，则会继续下面的操作，客户端再次产生一个随机数（第三个随机数），然后使用服务器证书中的公钥进行加密，以及放一个ChangeCipherSpec消息即编码改变的消息，还有整个前面所有消息的hash值，进行服务器验证，然后用新秘钥加密一段数据一并发送到服务器，确保正式通信前无误。</p>
<p>客户端使用前面的两个随机数以及刚刚新生成的新随机数，使用与服务器确定的加密算法，生成一个Session Secret。</p>
<p><strong><font color="#FF7256">ChangeCipherSpec</font></strong> </p>
<blockquote>
<p>ChangeCipherSpec是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。</p>
</blockquote>
<p><strong><font color="#FF7256">服务器再次响应</font></strong> </p>
<p>服务端在接收到客户端传过来的第三个随机数的 加密数据之后，使用私钥对这段加密数据进行解密，并对数据进行验证，也会使用跟客户端同样的方式生成秘钥，一切准备好之后，也会给客户端发送一个 ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了。之后，服务端也会使用 Session Secret 加密一段 Finish 消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。</p>
<p><strong><font color="#FF7256">后续客户端与服务器间通信</font></strong> </p>
<p>确定秘钥之后，服务器与客户端之间就会通过商定的秘钥加密消息了，进行通讯了。整个握手过程也就基本完成了。</p>
<p>值得特别提出的是：</p>
<blockquote>
<p>SSL协议在握手阶段使用的是非对称加密，在传输阶段使用的是对称加密，也就是说在SSL上传送的数据是使用对称密钥加密的！因为非对称加密的速度缓慢，耗费资源。其实当客户端和主机使用非对称加密方式建立连接后，客户端和主机已经决定好了在传输过程使用的对称加密算法和关键的对称加密密钥，由于这个过程本身是安全可靠的，也即对称加密密钥是不可能被窃取盗用的，因此，保证了在传输过程中对数据进行对称加密也是安全可靠的，因为除了客户端和主机之外，不可能有第三方窃取并解密出对称加密密钥！如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。</p>
</blockquote>
<p><strong><font color="#FF7256">其他补充</font></strong> </p>
<p>对于非常重要的保密数据，服务端还需要对客户端进行验证，以保证数据传送给了安全的合法的客户端。服务端可以向客户端发出 Cerficate Request 消息，要求客户端发送证书对客户端的合法性进行验证。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<p>PreMaster secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号，因为在Client Hello阶段，客户端会发送一份加密套件列表和当前支持的SSL/TLS的版本号给服务端，而且是使用明文传送的，如果握手的数据包被破解之后，攻击者很有可能串改数据包，选择一个安全性较低的加密套件和版本给服务端，从而对数据进行破解。所以，服务端需要对密文中解密出来对的PreMaster版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被串改，则立即停止发送任何消息。</p>
<p><strong><font color="#FF7256">session的恢复</font></strong> </p>
<p>有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。</p>
<p><strong><font color="#FF7256">session ID</font></strong>  </p>
<p>session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。</p>
<blockquote>
<p>session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。</p>
</blockquote>
<p><strong><font color="#FF7256">session ticket</font></strong>  </p>
<p>客户端发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。</p>
<blockquote>
<p>目前只有Firefox和Chrome浏览器支持。</p>
</blockquote>
<p><strong><font color="#FF7256">总结</font></strong> </p>
<p>https实际就是在TCP层与http层之间加入了SSL/TSL来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。</p>
<h5 id="SSL-速度"><a href="#SSL-速度" class="headerlink" title="SSL 速度"></a><strong><font color="#FF7256">SSL 速度</font></strong></h5><p>HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。</p>
<p>SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。</p>
<p>和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。</p>
<p>另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。</p>
<p>针对速度变慢这一问题，并没有根本性的解决方案，我们会使用 SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。</p>
<p><strong><font color="#FF7256">为什么不一直使用 HTTPS？</font></strong> </p>
<p>既然 HTTPS 那么安全可靠，那为何所有的 Web 网站不一直使用 HTTPS ？</p>
<p>其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。</p>
<p>因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。</p>
<p>特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。</p>
<p>而且，https禁用了缓存。</p>
<p>除此之外，想要节约购买证书的开销也是原因之一。</p>
<p>要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。证书价格可能会根据不同的认证机构略有不同。</p>
<p>那些购买证书并不合算的服务以及一些个人网站，可能只会选择采用 HTTP 的通信方式。</p>
<h5 id="SSL-客户端认证"><a href="#SSL-客户端认证" class="headerlink" title="SSL 客户端认证"></a><strong><font color="#FF7256">SSL 客户端认证</font></strong></h5><p>从使用用户 ID 和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果用户 ID 和密码被盗，就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。</p>
<p>SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书（在 HTTPS 一章已讲解）认证，服务器可确认访问是否来自已登录的客户端。</p>
<p><strong><font color="#FF7256">SSL 客户端认证的认证步骤</font></strong> </p>
<p>为达到 SSL 客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。</p>
<p>步骤 1： 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。</p>
<p>步骤 2： 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</p>
<p>步骤 3： 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。</p>
<p><strong><font color="#FF7256">SSL 客户端认证采用双因素认证</font></strong> </p>
<p>在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证（稍后讲解）组合形成一种双因素认证（Two-factor authentication）来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。</p>
<p>换言之，第一个认证因素的 SSL 客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。</p>
<p>通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算机访问服务器。</p>
<p><strong><font color="#FF7256">SSL 客户端认证必要的费用</font></strong> </p>
<p>使用 SSL 客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用。</p>
<p>这里提到的费用是指，从认证机构购买客户端证书的费用，以及服务器运营者为保证自己搭建的认证机构安全运营所产生的费用。</p>
<p>每个认证机构颁发客户端证书的费用不尽相同，平摊到一张证书上，一年费用约几万至十几万日元。服务器运营者也可以自己搭建认证机构，但要维持安全运行就会产生相应的费用。</p>
<h3 id="三、SOCKET"><a href="#三、SOCKET" class="headerlink" title="三、SOCKET"></a><strong><font color="#FF7256">三、SOCKET</font></strong></h3><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</p>
<p>建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。</p>
<p>Socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket，一个Socket由一个IP地址和一个端口号唯一确定。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。Socket是TCP/IP协议的一个十分流行的编程界面，但是，Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。</p>
<p>Socket通讯过程：服务端监听某个端口是否有连接请求，客户端向服务端发送连接请求，服务端收到连接请求向客户端发出接收消息，这样一个连接就建立起来了。客户端和服务端都可以相互发送消息与对方进行通讯。</p>
<p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p>
<p><strong><font color="#FF7256">套接字（socket）概念：</font></strong></p>
<p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
<p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<p><strong><font color="#FF7256">建立socket连接：</font></strong></p>
<p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket。</p>
<p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<ol>
<li><p>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求；</p>
</li>
<li><p>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p>
</li>
<li><p>连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
</li>
</ol>
<p><strong><font color="#FF7256">SOCKET连接与TCP连接</font></strong></p>
<p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p>
<p>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端。</p>
<p>socket的基本操作：</p>
<p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p>
<p><strong><font color="#FF7256">socket()函数</font></strong></p>
<p>int socket(int domain, int type, int protocol);</p>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p>
<blockquote>
<p>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。<br>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。<br>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。</p>
</blockquote>
<p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p>
<p>当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<p><strong><font color="#FF7256">bind()函数</font></strong></p>
<p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<p>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<p>函数的三个参数分别为：</p>
<blockquote>
<p>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。<br>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同：</p>
</blockquote>
<p>如ipv4对应的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct sockaddr_in &#123;</div><div class="line">    sa_family_t    sin_family; /* address family: AF_INET */</div><div class="line">    in_port_t      sin_port;   /* port in network byte order */</div><div class="line">    struct in_addr sin_addr;   /* internet address */</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/* Internet address. */</div><div class="line">struct in_addr &#123;</div><div class="line">    uint32_t       s_addr;     /* address in network byte order */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>ipv6对应的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct sockaddr_in6 &#123; </div><div class="line">    sa_family_t     sin6_family;   /* AF_INET6 */ </div><div class="line">    in_port_t       sin6_port;     /* port number */ </div><div class="line">    uint32_t        sin6_flowinfo; /* IPv6 flow information */ </div><div class="line">    struct in6_addr sin6_addr;     /* IPv6 address */ </div><div class="line">    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ </div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct in6_addr &#123; </div><div class="line">    unsigned char   s6_addr[16];   /* IPv6 address */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Unix域对应的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> #define UNIX_PATH_MAX    108</div><div class="line"></div><div class="line">struct sockaddr_un &#123; </div><div class="line">    sa_family_t sun_family;               /* AF_UNIX */ </div><div class="line">    char        sun_path[UNIX_PATH_MAX];  /* pathname */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>addrlen：对应的是地址的长度。</p>
</blockquote>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
<p>网络字节序与主机字节序</p>
<p>主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：</p>
<p>　　a. Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p>
<p>　　b. Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p>
<p>网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p>
<p>所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。</p>
<p><strong><font color="#FF7256">listen()、connect()函数</font></strong></p>
<p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, socklen_t addrlen)</span></span>;</div></pre></td></tr></table></figure></p>
<p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<p><strong><font color="#FF7256">accept()函数</font></strong></p>
<p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, socklen_t *addrlen)</span></span>;</div></pre></td></tr></table></figure></p>
<p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
<p>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<p><strong><font color="#FF7256">read()、write()等函数</font></strong></p>
<p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">read()/write()</div><div class="line">recv()/send()</div><div class="line">readv()/writev()</div><div class="line">recvmsg()/sendmsg()</div><div class="line">recvfrom()/sendto()</div></pre></td></tr></table></figure></p>
<p>我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">ssize_t read(int fd, void *buf, size_t count);</div><div class="line">ssize_t write(int fd, const void *buf, size_t count);</div><div class="line"></div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line"></div><div class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</div><div class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</div><div class="line"></div><div class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</div><div class="line">               const struct sockaddr *dest_addr, socklen_t addrlen);</div><div class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</div><div class="line">                 struct sockaddr *src_addr, socklen_t *addrlen);</div><div class="line"></div><div class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</div><div class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</div></pre></td></tr></table></figure></p>
<p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p>
<p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p>
<p>其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。</p>
<p><strong><font color="#FF7256">close()函数</font></strong></p>
<p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">int close(int fd);</div></pre></td></tr></table></figure></p>
<p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p>
<p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
<h4 id="N层交换技术"><a href="#N层交换技术" class="headerlink" title="N层交换技术"></a><strong><font color="#FF7256">N层交换技术</font></strong></h4><p><strong><font color="#FF7256">二层交换技术</font></strong></p>
<p>交换原理：根据第二层数据链路层的MAC地址来实现端到端的数据交换</p>
<p>工作流程：</p>
<p>（1）交换机某端口收到数据包，读取源MAC地址，得到源MAC地址机器所连端口；</p>
<p>（2）读取目的MAC地址，在地址表中查找对应端口；</p>
<p>（3）如果地址表中有目的MAC地址对应端口，直接复制数据至此端口；</p>
<p>（4）如果地址表中没有目的MAC地址对应端口，广播所有端口，当目的机器回应时，更新地址表，下次就不需要广播了。</p>
<p>不断的循环上述过程，全网的MAC地址信息都可以学习到，二层交换机就这样学习和维护它的地址表。第二层交换机根据MAC选择端口转发数据，算法又很简单，其方便采用廉价芯片实现，且速度快。</p>
<p><strong><font color="#FF7256">三层交换技术</font></strong></p>
<p>交换原理：根据第三层网络层的IP地址来完成端到端的数据交换；</p>
<blockquote>
<p><strong><font color="#FF7256">场景：A(ip1) =&gt;  三层交换机 =&gt;  B(ip2)</font></strong></p>
</blockquote>
<p>工作流程：</p>
<p>（1）A发数据给B，根据B的ip地址+子网掩码，A能够判断出B和自己是否在同一个网段；</p>
<p>（2）B如果和A在同一个网段内，但A不知道B的MAC地址，A会发送一个ARP请求，以获取B的MAC地址，并根据MAC通过二层交换机将数据发送给B；</p>
<p>（3）B如果和A不在同一个网段内，且不知道B的MAC地址，A会将数据包发送给网关（A的本地一定有网关的MAC地址）。网关收到数据包后，将源MAC地址会修改为网关自己的MAC地址，目的IP对应的MAC地址为目的MAC地址，以完成数据交换。<br>看似第三层交换机是第二层交换机+路由功能的组合，实际并非这样：数据通过第三层转发设备后，会记录IP与MAC的映射关系，下次需要转发时，不会再经过第三层设备。</p>
<p><strong><font color="#FF7256">四层交换技术</font></strong></p>
<p>二层和三层交换设备都是基于端到端的交换，这种基于IP和MAC地址的交换技术，有着很高效传输率，但是缺乏根据目的主机应用需求动态交换数据的功能。</p>
<p>四层设备不但能够完成端到端的交换，还能够根据目的主机的应用特点，分配或限制其流量；</p>
<p>四层设备基于传输层数据包交换，是一类建立在TCP/IP应用层至上，实现用户应用需求的设备；它实现一类应用层的访问控制与质量保证服务，与其说它是硬件设备，不如说它是软件网络管理系统。</p>
<p><strong><font color="#FF7256">四层交换核心技术</font></strong></p>
<ol>
<li><p>包过滤<br>利用四层信息定义过滤规则，能够控制指定端口的TCP/UDP通信，它可以在高速芯片中实现，极大提高包过滤速率；</p>
</li>
<li><p>包优先级<br>三层以下设备只有MAC，PORT，IP等信息，因为缺乏四层信息，无法确认TCP/IP等四层优先级信息；四层设备允许基于目的地址/端口（即应用服务）的组合来区分优先级。</p>
</li>
<li><p>负载均衡<br>将附加有负载均衡服务的IP地址，通过不同的物理服务做成一个集群，提供相同的服务，并将其定义为一个单独的虚拟服务器；<br>这个虚拟服务器是一个有独立IP的逻辑服务器，用户数据流只需要流向虚拟服务器IP，而不与物理服务器进行通信；<br>只有通过交换机执行网络地址转换（NAT）后，才能得到真实访问；<br>虚拟服务器组里转换通信流量实现均衡，其中具体关系到OSPF、RIP、VRRP等协议；</p>
</li>
<li><p>主机备用连接<br>同（3）所含技术类似，可以实现主备同IP自动切换；</p>
</li>
</ol>
<p><strong><font color="#FF7256">七层交换技术</font></strong></p>
<p>交换原理：比四层更进一步，可以根据应用层的数据报文来完成更多的复杂交换功能（例如根据http报文路由）。由于七层交换还没有具体的标准，文章也不多展开啦。</p>
<p><strong><font color="#FF7256">JDK Socket</font></strong></p>
<p>在java.net包下有两个类：Socket和ServerSocket。ServerSocket用于服务器端，Socket是建立网络连接时使用的。在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。对于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在客户端而产生不同级别。不管是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的。</p>
<p><strong><font color="#FF7256">列出几个常用的构造方法：</font></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Socket(InetAddress address,<span class="keyword">int</span> port); <span class="comment">//创建一个流套接字并将其连接到指定 IP 地址的指定端口号；</span></div><div class="line">Socket(String host,<span class="keyword">int</span> port); <span class="comment">//创建一个流套接字并将其连接到指定主机上的指定端口号；</span></div><div class="line">Socket(InetAddress address,<span class="keyword">int</span> port, InetAddress localAddr,<span class="keyword">int</span> localPort); <span class="comment">//创建一个套接字并将其连接到指定远程地址上的指定远程端口；</span></div><div class="line">Socket(String host,<span class="keyword">int</span> port, InetAddress localAddr,<span class="keyword">int</span> localPort); <span class="comment">//创建一个套接字并将其连接到指定远程主机上的指定远程端口；</span></div><div class="line">Socket(SocketImpl impl); <span class="comment">//使用用户指定的 SocketImpl 创建一个未连接 Socket；</span></div><div class="line">ServerSocket(<span class="keyword">int</span> port); <span class="comment">//创建绑定到特定端口的服务器套接字；</span></div><div class="line">ServerSocket(<span class="keyword">int</span> port,<span class="keyword">int</span> backlog); <span class="comment">//利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号；</span></div><div class="line">ServerSocket(<span class="keyword">int</span> port,<span class="keyword">int</span> backlog, InetAddress bindAddr); <span class="comment">//使用指定的端口、侦听 backlog 和要绑定到的本地 IP地址创建服务器；</span></div></pre></td></tr></table></figure></p>
<p>构造方法的参数中，address、host和port分别是双向连接中另一方的IP地址、主机名和端 口号，stream指明socket是流socket还是数据报socket，localPort表示本地主机的端口号，localAddr和bindAddr是本地机器的地址（ServerSocket的主机地址），impl是socket的父类，既可以用来创建serverSocket又可以用来创建Socket。count则表示服务端所能支持的最大连接数。</p>
<p>注意：必须小心选择端口号。每一个端口提供一种特定的服务，只有给出正确的端口，才能获得相应的服务。0~1023的端口号为系统所保留，例如http服务的端口号为80,telnet服务的端口号为21,ftp服务的端口号为23, 所以我们在选择端口号时，最好选择一个大于1023的数以防止发生冲突。</p>
<p><strong><font color="#FF7256">几个重要的Socket方法：</font></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>; <span class="comment">//方法获得网络连接输入，同时返回一个IutputStream对象实例；</span></div><div class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>; <span class="comment">//方法连接的另一端将得到输入，同时返回一个OutputStream对象实例；</span></div><div class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span></span>; <span class="comment">//用于产生"阻塞"，直到接受到一个连接，并且返回一个客户端的Socket对象实例。</span></div></pre></td></tr></table></figure></p>
<p>“阻塞”是一个术语，它使程序运行暂时”停留”在这个地方，直到一个会话产生，然后程序继续；通常”阻塞”是由循环产生的。</p>
<p>注意：其中getInputStream和getOutputStream方法均会产生一个IOException，它必须被捕获，因为它们返回的流对象，通常都会被另一个流对象使用。</p>
<p><strong><font color="#FF7256">基本的Client/Server程序</font></strong></p>
<p>以下是一个基本的客户端/服务器端程序代码。主要实现了服务器端一直监听某个端口，等待客户端连接请求。客户端根据IP地址和端口号连接服务器端，从键盘上输入一行信息，发送到服务器端，然后接收服务器端返回的信息，最后结束会话。这个程序一次只能接受一个客户连接。</p>
<p>客户端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/** 创建Socket*/</span></div><div class="line">            <span class="comment">// 创建一个流套接字并将其连接到指定 IP 地址的指定端口号(本处是本机)</span></div><div class="line">            Socket socket =<span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">2013</span>);</div><div class="line">            <span class="comment">// 60s超时</span></div><div class="line">            socket.setSoTimeout(<span class="number">60000</span>);</div><div class="line"></div><div class="line">            <span class="comment">/** 发送客户端准备传输的信息 */</span></div><div class="line">            <span class="comment">// 由Socket对象得到输出流，并构造PrintWriter对象</span></div><div class="line">            PrintWriter printWriter =<span class="keyword">new</span> PrintWriter(socket.getOutputStream(),<span class="keyword">true</span>);</div><div class="line">            <span class="comment">// 将输入读入的字符串输出到Server</span></div><div class="line">            BufferedReader sysBuff =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">            printWriter.println(sysBuff.readLine());</div><div class="line">            <span class="comment">// 刷新输出流，使Server马上收到该字符串</span></div><div class="line">            printWriter.flush();</div><div class="line"></div><div class="line">            <span class="comment">/** 用于获取服务端传输来的信息 */</span></div><div class="line">            <span class="comment">// 由Socket对象得到输入流，并构造相应的BufferedReader对象</span></div><div class="line">            BufferedReader bufferedReader =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line">            <span class="comment">// 输入读入一字符串</span></div><div class="line">            String result = bufferedReader.readLine();</div><div class="line">            System.out.println(<span class="string">"Server say : "</span> + result);</div><div class="line"></div><div class="line">            <span class="comment">/** 关闭Socket*/</span></div><div class="line">            printWriter.close();</div><div class="line">            bufferedReader.close();</div><div class="line">            socket.close();</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"Exception:"</span> + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/** 创建ServerSocket*/</span></div><div class="line">            <span class="comment">// 创建一个ServerSocket在端口2013监听客户请求</span></div><div class="line">            ServerSocket serverSocket =<span class="keyword">new</span> ServerSocket(<span class="number">2013</span>);</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="comment">// 侦听并接受到此Socket的连接,请求到来则产生一个Socket对象，并继续执行</span></div><div class="line">                Socket socket = serverSocket.accept();</div><div class="line"></div><div class="line">                <span class="comment">/** 获取客户端传来的信息 */</span></div><div class="line">                <span class="comment">// 由Socket对象得到输入流，并构造相应的BufferedReader对象</span></div><div class="line">                BufferedReader bufferedReader =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line">                <span class="comment">// 获取从客户端读入的字符串</span></div><div class="line">                String result = bufferedReader.readLine();</div><div class="line">                System.out.println(<span class="string">"Client say : "</span> + result);</div><div class="line"></div><div class="line">                <span class="comment">/** 发送服务端准备传输的 */</span></div><div class="line">                <span class="comment">// 由Socket对象得到输出流，并构造PrintWriter对象</span></div><div class="line">                PrintWriter printWriter =<span class="keyword">new</span> PrintWriter(socket.getOutputStream());</div><div class="line">                printWriter.print(<span class="string">"hello Client, I am Server!"</span>);</div><div class="line">                printWriter.flush();</div><div class="line"></div><div class="line">                <span class="comment">/** 关闭Socket*/</span></div><div class="line">                printWriter.close();</div><div class="line">                bufferedReader.close();</div><div class="line">                socket.close();</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"Exception:"</span> + e);</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            <span class="comment">//serverSocket.close();</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">多客户端连接服务器</font></strong></p>
<p>上面的服务器端程序一次只能连接一个客户端，这在实际应用中显然是不可能的。通常的网络环境是多个客户端连接到某个主机进行通讯，所以我们要对上面的程序进行改造。</p>
<p>设计思路：服务器端主程序监听某一个端口，客户端发起连接请求，服务器端主程序接收请求，同时构造一个线程类，用于接管会话。当一个Socket会话产生后，这个会话就会交给线程进行处理，主程序继续进行监听。</p>
<p>下面的实现程序流程是：客户端和服务器建立连接，客户端发送消息，服务端根据消息进行处理并返回消息，若客户端申请关闭，则服务器关闭此连接，双方通讯结束。</p>
<p>客户端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Socket socket =<span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">2013</span>);</div><div class="line">            socket.setSoTimeout(<span class="number">60000</span>);</div><div class="line"></div><div class="line">            PrintWriter printWriter =<span class="keyword">new</span> PrintWriter(socket.getOutputStream(),<span class="keyword">true</span>);</div><div class="line">            BufferedReader bufferedReader =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line"></div><div class="line">            String result =<span class="string">""</span>;</div><div class="line">            <span class="keyword">while</span>(result.indexOf(<span class="string">"bye"</span>) == -<span class="number">1</span>)&#123;</div><div class="line">                BufferedReader sysBuff =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">                printWriter.println(sysBuff.readLine());</div><div class="line">                printWriter.flush();</div><div class="line"></div><div class="line">                result = bufferedReader.readLine();</div><div class="line">                System.out.println(<span class="string">"Server say : "</span> + result);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            printWriter.close();</div><div class="line">            bufferedReader.close();</div><div class="line">            socket.close();</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"Exception:"</span> + e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器端程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">import</span> java.net.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">ServerSocket</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT =<span class="number">2013</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">super</span>(SERVER_PORT);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                Socket socket = accept();</div><div class="line">                <span class="keyword">new</span> CreateServerThread(socket);<span class="comment">//当有请求时，启一个线程处理</span></div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//线程类</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CreateServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> Socket client;</div><div class="line">        <span class="keyword">private</span> BufferedReader bufferedReader;</div><div class="line">        <span class="keyword">private</span> PrintWriter printWriter;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CreateServerThread</span><span class="params">(Socket s)</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            client = s;</div><div class="line"></div><div class="line">            bufferedReader =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</div><div class="line"></div><div class="line">            printWriter =<span class="keyword">new</span> PrintWriter(client.getOutputStream(),<span class="keyword">true</span>);</div><div class="line">            System.out.println(<span class="string">"Client("</span> + getName() +<span class="string">") come in..."</span>);</div><div class="line"></div><div class="line">            start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                String line = bufferedReader.readLine();</div><div class="line"></div><div class="line">                <span class="keyword">while</span> (!line.equals(<span class="string">"bye"</span>)) &#123;</div><div class="line">                    printWriter.println(<span class="string">"continue, Client("</span> + getName() +<span class="string">")!"</span>);</div><div class="line">                    line = bufferedReader.readLine();</div><div class="line">                    System.out.println(<span class="string">"Client("</span> + getName() +<span class="string">") say: "</span> + line);</div><div class="line">                &#125;</div><div class="line">                printWriter.println(<span class="string">"bye, Client("</span> + getName() +<span class="string">")!"</span>);</div><div class="line"></div><div class="line">                System.out.println(<span class="string">"Client("</span> + getName() +<span class="string">") exit!"</span>);</div><div class="line">                printWriter.close();</div><div class="line">                bufferedReader.close();</div><div class="line">                client.close();</div><div class="line">            &#125;<span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">new</span> Server();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">信息群发共享</font></strong></p>
<p>以上虽然实现了多个客户端和服务器连接，但是仍然是消息在一个客户端和服务器之间相互传播。现在我们要实现信息共享，即服务器可以向多个客户端发送广播消息，客户端也可以向其他客户端发送消息。类似于聊天室的那种功能，实现信息能在多个客户端之间共享。</p>
<p>设计思路：客户端循环可以不停输入向服务器发送消息，并且启一个线程，专门用来监听服务器端发来的消息并打印输出。服务器端启动时，启动一个监听何时需要向客户端发送消息的线程。每次接受客户端连接请求，都启一个线程进行处理，并且将客户端信息存放到公共集合中。当客户端发送消息时，服务器端将消息顺序存入队列中，当需要输出时，从队列中取出广播到各客户端处。客户端输入showuser命令可以查看在线用户列表，输入bye向服务器端申请退出连接。</p>
<p>客户端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> <span class="keyword">extends</span> <span class="title">Socket</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_IP =<span class="string">"127.0.0.1"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT =<span class="number">2013</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Socket client;</div><div class="line">    <span class="keyword">private</span> PrintWriter out;</div><div class="line">    <span class="keyword">private</span> BufferedReader in;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 与服务器连接，并输入发送消息</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">super</span>(SERVER_IP, SERVER_PORT);</div><div class="line">        client =<span class="keyword">this</span>;</div><div class="line">        out =<span class="keyword">new</span> PrintWriter(<span class="keyword">this</span>.getOutputStream(),<span class="keyword">true</span>);</div><div class="line">        in =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">this</span>.getInputStream()));</div><div class="line">        <span class="keyword">new</span> readLineThread();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            in =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">            String input = in.readLine();</div><div class="line">            out.println(input);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于监听服务器端向客户端发送消息线程类</div><div class="line">     */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">readLineThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> BufferedReader buff;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">readLineThread</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                buff =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</div><div class="line">                start();</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                    String result = buff.readLine();</div><div class="line">                    <span class="keyword">if</span>(<span class="string">"byeClient"</span>.equals(result))&#123;<span class="comment">//客户端申请退出，服务端返回确认退出</span></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//输出服务端发送消息</span></div><div class="line">                        System.out.println(result);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                in.close();</div><div class="line">                out.close();</div><div class="line">                client.close();</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">new</span> SocketClient();<span class="comment">//启动客户端</span></div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">ServerSocket</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT =<span class="number">2013</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPrint =<span class="keyword">false</span>;<span class="comment">//是否输出消息标志</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List user_list =<span class="keyword">new</span> ArrayList();<span class="comment">//登录用户集合</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ServerThread&gt; thread_list =<span class="keyword">new</span> ArrayList&lt;ServerThread&gt;();<span class="comment">//服务器已启用线程集合</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedList&lt;String&gt; message_list =<span class="keyword">new</span> LinkedList&lt;String&gt;();<span class="comment">//存放消息队列</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建服务端Socket,创建向客户端发送消息线程,监听客户端请求并处理</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">        <span class="keyword">super</span>(SERVER_PORT);<span class="comment">//创建ServerSocket</span></div><div class="line">        <span class="keyword">new</span> PrintOutThread();<span class="comment">//创建向客户端发送消息线程</span></div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;<span class="comment">//监听客户端请求，启个线程处理</span></div><div class="line">                Socket socket = accept();</div><div class="line">                <span class="keyword">new</span> ServerThread(socket);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 监听是否有输出消息请求线程类,向客户端发送消息</div><div class="line">     */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PrintOutThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintOutThread</span><span class="params">()</span></span>&#123;</div><div class="line">            start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(isPrint)&#123;<span class="comment">//将缓存在队列中的消息按顺序发送到各客户端，并从队列中清除。</span></div><div class="line">                    String message = message_list.getFirst();</div><div class="line">                    <span class="keyword">for</span> (ServerThread thread : thread_list) &#123;</div><div class="line">                        thread.sendMessage(message);</div><div class="line">                    &#125;</div><div class="line">                    message_list.removeFirst();</div><div class="line">                    isPrint = message_list.size() &gt;<span class="number">0</span> ?<span class="keyword">true</span> :<span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 服务器线程类</div><div class="line">     */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> Socket client;</div><div class="line">        <span class="keyword">private</span> PrintWriter out;</div><div class="line">        <span class="keyword">private</span> BufferedReader in;</div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket s)</span><span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">            client = s;</div><div class="line">            out =<span class="keyword">new</span> PrintWriter(client.getOutputStream(),<span class="keyword">true</span>);</div><div class="line">            in =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</div><div class="line">            in.readLine();</div><div class="line">            out.println(<span class="string">"成功连上聊天室,请输入你的名字："</span>);</div><div class="line">            start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">int</span> flag =<span class="number">0</span>;</div><div class="line">                String line = in.readLine();</div><div class="line">                <span class="keyword">while</span>(!<span class="string">"bye"</span>.equals(line))&#123;</div><div class="line">                    <span class="comment">//查看在线用户列表</span></div><div class="line">                    <span class="keyword">if</span> (<span class="string">"showuser"</span>.equals(line)) &#123;</div><div class="line">                        out.println(<span class="keyword">this</span>.listOnlineUsers());</div><div class="line">                        line = in.readLine();</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//第一次进入，保存名字</span></div><div class="line">                    <span class="keyword">if</span>(flag++ ==<span class="number">0</span>)&#123;</div><div class="line">                        name = line;</div><div class="line">                        user_list.add(name);</div><div class="line">                        thread_list.add(<span class="keyword">this</span>);</div><div class="line">                        out.println(name +<span class="string">"你好,可以开始聊天了..."</span>);</div><div class="line">                        <span class="keyword">this</span>.pushMessage(<span class="string">"Client&lt;"</span> + name +<span class="string">"&gt;进入聊天室..."</span>);</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        <span class="keyword">this</span>.pushMessage(<span class="string">"Client&lt;"</span> + name +<span class="string">"&gt; say : "</span> + line);</div><div class="line">                    &#125;</div><div class="line">                    line = in.readLine();</div><div class="line">                &#125;</div><div class="line">                out.println(<span class="string">"byeClient"</span>);</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;<span class="keyword">finally</span>&#123;<span class="comment">//用户退出聊天室</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    client.close();</div><div class="line">                &#125;<span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                thread_list.remove(<span class="keyword">this</span>);</div><div class="line">                user_list.remove(name);</div><div class="line">                pushMessage(<span class="string">"Client&lt;"</span> + name +<span class="string">"&gt;退出了聊天室"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//放入消息队列末尾，准备发送给客户端</span></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushMessage</span><span class="params">(String msg)</span></span>&#123;</div><div class="line">            message_list.addLast(msg);</div><div class="line">            isPrint =<span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//向客户端发送一条消息</span></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</div><div class="line">            out.println(msg);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//统计在线用户列表</span></div><div class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">listOnlineUsers</span><span class="params">()</span> </span>&#123;</div><div class="line">            String s =<span class="string">"--- 在线用户列表 ---\015\012"</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; user_list.size(); i++) &#123;</div><div class="line">                s +=<span class="string">"["</span> + user_list.get(i) +<span class="string">"]\015\012"</span>;</div><div class="line">            &#125;</div><div class="line">            s +=<span class="string">"--------------------"</span>;</div><div class="line">            <span class="keyword">return</span> s;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">new</span> Server();<span class="comment">//启动服务端</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">文件传输</font></strong></p>
<p>客户端向服务器端传送文件，服务端可获取文件名用于保存，获取文件大小计算传输进度，比较简单，直接贴代码。</p>
<p>客户端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.DataOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 客户端</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">Socket</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_IP =<span class="string">"127.0.0.1"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT =<span class="number">2013</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Socket client;</div><div class="line">    <span class="keyword">private</span> FileInputStream fis;</div><div class="line">    <span class="keyword">private</span> DataOutputStream dos;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                client =<span class="keyword">new</span> Socket(SERVER_IP, SERVER_PORT);</div><div class="line">                <span class="comment">//向服务端传送文件</span></div><div class="line">                File file =<span class="keyword">new</span> File(<span class="string">"c:/test.doc"</span>);</div><div class="line">                fis =<span class="keyword">new</span> FileInputStream(file);</div><div class="line">                dos =<span class="keyword">new</span> DataOutputStream(client.getOutputStream());</div><div class="line"></div><div class="line">                <span class="comment">//文件名和长度</span></div><div class="line">                dos.writeUTF(file.getName());</div><div class="line">                dos.flush();</div><div class="line">                dos.writeLong(file.length());</div><div class="line">                dos.flush();</div><div class="line"></div><div class="line">                <span class="comment">//传输文件</span></div><div class="line">                <span class="keyword">byte</span>[] sendBytes =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">                <span class="keyword">int</span> length =<span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span>((length = fis.read(sendBytes,<span class="number">0</span>, sendBytes.length)) &gt;<span class="number">0</span>)&#123;</div><div class="line">                    dos.write(sendBytes,<span class="number">0</span>, length);</div><div class="line">                    dos.flush();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;<span class="keyword">finally</span>&#123;</div><div class="line">                <span class="keyword">if</span>(fis !=<span class="keyword">null</span>)</div><div class="line">                    fis.close();</div><div class="line">                <span class="keyword">if</span>(dos !=<span class="keyword">null</span>)</div><div class="line">                    dos.close();</div><div class="line">                client.close();</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">new</span> Client();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> sock;</div><div class="line"><span class="keyword">import</span> java.io.DataInputStream;</div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 服务器</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">ServerSocket</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT =<span class="number">2013</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ServerSocket server;</div><div class="line">    <span class="keyword">private</span> Socket client;</div><div class="line">    <span class="keyword">private</span> DataInputStream dis;</div><div class="line">    <span class="keyword">private</span> FileOutputStream fos;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                server =<span class="keyword">new</span> ServerSocket(PORT);</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                    client = server.accept();</div><div class="line">                    dis =<span class="keyword">new</span> DataInputStream(client.getInputStream());</div><div class="line">                    <span class="comment">//文件名和长度</span></div><div class="line">                    String fileName = dis.readUTF();</div><div class="line">                    <span class="keyword">long</span> fileLength = dis.readLong();</div><div class="line">                    fos =<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"d:/"</span> + fileName));</div><div class="line">                    <span class="keyword">byte</span>[] sendBytes =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">                    <span class="keyword">int</span> transLen =<span class="number">0</span>;</div><div class="line">                    System.out.println(<span class="string">"----开始接收文件&lt;"</span> + fileName +<span class="string">"&gt;,文件大小为&lt;"</span> + fileLength +<span class="string">"&gt;----"</span>);</div><div class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                        <span class="keyword">int</span> read =<span class="number">0</span>;</div><div class="line">                        read = dis.read(sendBytes);</div><div class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>)</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        transLen += read;</div><div class="line">                        System.out.println(<span class="string">"接收文件进度"</span> +<span class="number">100</span> * transLen/fileLength +<span class="string">"%..."</span>);</div><div class="line">                        fos.write(sendBytes,<span class="number">0</span>, read);</div><div class="line">                        fos.flush();</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(<span class="string">"----接收文件&lt;"</span> + fileName +<span class="string">"&gt;成功-------"</span>);</div><div class="line">                    client.close();</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;<span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">if</span>(dis !=<span class="keyword">null</span>)</div><div class="line">                    dis.close();</div><div class="line">                <span class="keyword">if</span>(fos !=<span class="keyword">null</span>)</div><div class="line">                    fos.close();</div><div class="line">                server.close();</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">new</span> Server();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Socket通信简介"><a href="#Socket通信简介" class="headerlink" title="Socket通信简介"></a><strong><font color="#FF7256">Socket通信简介</font></strong></h4><p>Android与服务器的通信方式主要有两种，一是Http通信，一是Socket通信。两者的最大差异在于，http连接使用的是“请求—响应方式”，即在请求时建立连接通道，当客户端向服务器发送请求后，服务器端才能向客户端返回数据。而Socket通信则是在双方建立起连接后就可以直接进行数据的传输，在连接时可实现信息的主动推送，而不需要每次由客户端想服务器发送请求。 那么，什么是socket？Socket又称套接字，在程序内部提供了与外界通信的端口，即端口通信。通过建立socket连接，可为通信双方的数据传输传提供通道。socket的主要特点有数据丢失率低，使用简单且易于移植。</p>
<p><strong><font color="#FF7256">什么是Socket Socket</font></strong></p>
<p>是一种抽象层，应用程序通过它来发送和接收数据，使用Socket可以将应用程序添加到网络中，与处于同一网络中的其他应用程序进行通信。简单来说，Socket提供了程序内部与外界通信的端口并为通信双方的提供了数据传输通道。</p>
<p><strong><font color="#FF7256">Socket的分类</font></strong></p>
<p>根据不同的的底层协议，Socket的实现是多样化的。本指南中只介绍TCP/IP协议族的内容，在这个协议族当中主要的Socket类型为流套接字（streamsocket）和数据报套接字(datagramsocket)。流套接字将TCP作为其端对端协议，提供了一个可信赖的字节流服务。数据报套接字使用UDP协议，提供数据打包发送服务。 下面，我们来认识一下这两种Socket类型的基本实现模型。</p>
<p><strong><font color="#FF7256">Socket 基本通信模型</font></strong></p>
<p><strong><font color="#FF7256">Socket基本实现原理</font></strong></p>
<p><strong><font color="#FF7256">基于TCP协议的Socket</font></strong></p>
<p>服务器端首先声明一个ServerSocket对象并且指定端口号，然后调用Serversocket的accept()法接收客户端的数据。accept()方法在没有数据进行接收的处于堵塞状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Socket socket= serversocket.accept();</div></pre></td></tr></table></figure></p>
<p>一旦接收到数据，通过inputstream读取接收的数据。</p>
<p>客户端创建一个Socket对象，制定服务器端的IP地址和端口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"172.168.10.108"</span>,<span class="number">8080</span>);</div></pre></td></tr></table></figure></p>
<p>通过inputstream读取数据，获取服务器发出的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutputStream outputstream= socket.getOutputStream();</div></pre></td></tr></table></figure></p>
<p>最后将要发送的数据写入到outputstream即可进行TCP协议的socket数据传输。</p>
<p><strong><font color="#FF7256">基于UDP协议的数据传输</font></strong></p>
<p>服务器端首先创建一个DatagramSocket对象，并且指点监听的端口。接下来创建一个空的DatagramSocket对象用于接收数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">DatagramSocket packet= <span class="keyword">new</span> DatagramSocket(data，data.length);</div></pre></td></tr></table></figure></p>
<p>使用DatagramSocket的receive方法接收客户端发送的数据，receive（）与serversocket的accepet（）类似，在没有数据进行接收的处于堵塞状态。</p>
<p>客户端也创建个DatagramSocket对象，并且指点监听的端口。</p>
<p>接下来创建一个InetAddress对象，这个对象类似与一个网络的发送地址<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InetAddressserver address= InetAddress.getByName(<span class="string">"172.168.1.120"</span>)</div></pre></td></tr></table></figure></p>
<p>定义要发送的一个字符串，创建一个DatagramPacket对象，并制定要讲这个数据报包发送到网络的那个地址以及端口号。</p>
<p>最后使用DatagramSocket的对象的send（）发送数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str=<span class="string">"hello"</span>;</div><div class="line">bytedata[]=str.getByte();</div><div class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(data,data.length,serveraddress,<span class="number">4567</span>);</div><div class="line">socket.send(packet);</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">android 实现socket简单通信</font></strong></p>
<p>前言：添加权限<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 允许应用程序改变网络状态--&gt;</div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.CHANGE_NETWORK_STATE"</span>/&gt;</div><div class="line"></div><div class="line">&lt;!--允许应用程序改变WIFI连接状态 --&gt;</div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.CHANGE_WIFI_STATE"</span>&gt;</div><div class="line"></div><div class="line">&lt;!--允许应用程序访问有关的网络信息--&gt;</div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</div><div class="line"></div><div class="line">&lt;!--允许应用程序访问WIFI网卡的网络信息--&gt;</div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span>/&gt;</div><div class="line"></div><div class="line">&lt;!--允许应用程序完全使用网络--&gt;</div><div class="line"></div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">使用TCP协议通信</font></strong></p>
<p>android端实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connectServerWithTCPSocket</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	Socket socket;</div><div class="line"></div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">		</div><div class="line">		<span class="comment">// 创建一个Socket对象，并指定服务端的IP及端口号</span></div><div class="line"></div><div class="line">		socket =newSocket(<span class="string">"192.168.1.32"</span>,<span class="number">1989</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 创建一个InputStream用户读取要发送的文件。</span></div><div class="line"></div><div class="line">		InputStream inputStream =newFileInputStream(<span class="string">"e://a.txt"</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 获取Socket的OutputStream对象用于发送数据。</span></div><div class="line"></div><div class="line">		OutputStream outputStream = socket.getOutputStream();</div><div class="line"></div><div class="line">		<span class="comment">// 创建一个byte类型的buffer字节数组，用于存放读取的本地文件</span></div><div class="line"></div><div class="line">		bytebuffer[] =newbyte[<span class="number">4</span>*<span class="number">1024</span>];</div><div class="line"></div><div class="line">		inttemp =<span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="comment">// 循环读取文件</span></div><div class="line"></div><div class="line">		<span class="keyword">while</span>((temp = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">		<span class="comment">// 把数据写入到OuputStream对象中</span></div><div class="line"></div><div class="line">			outputStream.write(buffer,<span class="number">0</span>, temp);</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">// 发送读取的数据到服务端</span></div><div class="line"></div><div class="line">		outputStream.flush();</div><div class="line"></div><div class="line">	<span class="comment">/** 或创建一个报文，使用BufferedWriter写入,看你的需求 **/</span></div><div class="line"></div><div class="line">		<span class="comment">// String socketData = "[2143213;21343fjks;213]";</span></div><div class="line"></div><div class="line">		<span class="comment">// BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</span></div><div class="line"></div><div class="line">		<span class="comment">// writer.write(socketData.replace("\n", " ") + "\n");</span></div><div class="line"></div><div class="line">		<span class="comment">// writer.flush();</span></div><div class="line"></div><div class="line">		&#125;<span class="keyword">catch</span>(UnknownHostException e) &#123;</div><div class="line"></div><div class="line">			e.printStackTrace();</div><div class="line"></div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line"></div><div class="line">			e.printStackTrace();</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务器端简单实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ServerReceviedByTcp</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// 声明一个ServerSocket对象</span></div><div class="line"></div><div class="line">	ServerSocket serverSocket =<span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// 创建一个ServerSocket对象，并让这个Socket在1989端口监听</span></div><div class="line"></div><div class="line">		serverSocket =newServerSocket(<span class="number">1989</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 调用ServerSocket的accept()方法，接受客户端所发送的请求，</span></div><div class="line"></div><div class="line">	<span class="comment">// 如果客户端没有发送数据，那么该线程就停滞不继续</span></div><div class="line"></div><div class="line">		Socket socket = serverSocket.accept();</div><div class="line"></div><div class="line">	<span class="comment">// 从Socket当中得到InputStream对象</span></div><div class="line"></div><div class="line">		InputStream inputStream = socket.getInputStream();</div><div class="line"></div><div class="line">		bytebuffer[] =newbyte[<span class="number">1024</span>*<span class="number">4</span>];</div><div class="line"></div><div class="line">		inttemp =<span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 从InputStream当中读取客户端所发送的数据</span></div><div class="line"></div><div class="line">		<span class="keyword">while</span>((temp = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">			System.out.println(newString(buffer,<span class="number">0</span>, temp));</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		serverSocket.close();</div><div class="line"></div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line"></div><div class="line">			e.printStackTrace();</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">使用UDP协议通信</font></strong></p>
<p>客户端发送数据实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connectServerWithUDPSocket</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	DatagramSocket socket;</div><div class="line"></div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//创建DatagramSocket对象并指定一个端口号，注意，如果客户端需要接收服务器的返回数据,</span></div><div class="line"></div><div class="line">	<span class="comment">//还需要使用这个端口号来receive，所以一定要记住</span></div><div class="line"></div><div class="line">	socket =newDatagramSocket(<span class="number">1985</span>);</div><div class="line"></div><div class="line">	<span class="comment">//使用InetAddress(Inet4Address).getByName把IP地址转换为网络地址</span></div><div class="line"></div><div class="line">	InetAddress serverAddress = InetAddress.getByName(<span class="string">"192.168.1.32"</span>);</div><div class="line"></div><div class="line">	<span class="comment">//Inet4Address serverAddress = (Inet4Address) Inet4Address.getByName("192.168.1.32");</span></div><div class="line"></div><div class="line">	String str =<span class="string">"[2143213;21343fjks;213]"</span>;<span class="comment">//设置要发送的报文</span></div><div class="line"></div><div class="line">	bytedata[] = str.getBytes();<span class="comment">//把字符串str字符串转换为字节数组</span></div><div class="line"></div><div class="line">	<span class="comment">//创建一个DatagramPacket对象，用于发送数据。</span></div><div class="line"></div><div class="line">	<span class="comment">//参数一：要发送的数据  参数二：数据的长度  参数三：服务端的网络地址  参数四：服务器端端口号</span></div><div class="line"></div><div class="line">	DatagramPacket packet =newDatagramPacket(data, data.length ,serverAddress ,<span class="number">10025</span>);</div><div class="line"></div><div class="line">	socket.send(packet);<span class="comment">//把数据发送到服务端。</span></div><div class="line"></div><div class="line">	&#125;<span class="keyword">catch</span>(SocketException e) &#123;</div><div class="line"></div><div class="line">	e.printStackTrace();</div><div class="line"></div><div class="line">	&#125;<span class="keyword">catch</span>(UnknownHostException e) &#123;</div><div class="line"></div><div class="line">		e.printStackTrace();</div><div class="line"></div><div class="line">	&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line"></div><div class="line">		e.printStackTrace();</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端接收服务器返回的数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReceiveServerSocketData</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">		DatagramSocket socket;</div><div class="line"></div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">//实例化的端口号要和发送时的socket一致，否则收不到data</span></div><div class="line"></div><div class="line">		socket =newDatagramSocket(<span class="number">1985</span>);</div><div class="line"></div><div class="line">		bytedata[] =newbyte[<span class="number">4</span>*<span class="number">1024</span>];</div><div class="line"></div><div class="line">		<span class="comment">//参数一:要接受的data 参数二：data的长度</span></div><div class="line"></div><div class="line">		DatagramPacket packet =newDatagramPacket(data, data.length);</div><div class="line"></div><div class="line">		socket.receive(packet);</div><div class="line"></div><div class="line">		<span class="comment">//把接收到的data转换为String字符串</span></div><div class="line"></div><div class="line">		String result =newString(packet.getData(), packet.getOffset(),</div><div class="line"></div><div class="line">		packet.getLength());</div><div class="line"></div><div class="line">		socket.close();<span class="comment">//不使用了记得要关闭</span></div><div class="line"></div><div class="line">		System.out.println(<span class="string">"the number of reveived Socket is  :"</span>+ flag</div><div class="line"></div><div class="line">+<span class="string">"udpData:"</span>+ result);</div><div class="line"></div><div class="line">		&#125;<span class="keyword">catch</span>(SocketException e) &#123;</div><div class="line"></div><div class="line">			e.printStackTrace();</div><div class="line"></div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line"></div><div class="line">			e.printStackTrace();</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>服务器接收客户端实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ServerReceviedByUdp</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="comment">//创建一个DatagramSocket对象，并指定监听端口。（UDP使用DatagramSocket）</span></div><div class="line">    DatagramSocket socket;</div><div class="line">       <span class="keyword">try</span>&#123;</div><div class="line">	socket =newDatagramSocket(<span class="number">10025</span>);</div><div class="line">	<span class="comment">//创建一个byte类型的数组，用于存放接收到得数据</span></div><div class="line">	bytedata[] =newbyte[<span class="number">4</span>*<span class="number">1024</span>];</div><div class="line">	<span class="comment">//创建一个DatagramPacket对象，并指定DatagramPacket对象的大小</span></div><div class="line">	DatagramPacket packet =newDatagramPacket(data,data.length);</div><div class="line">	<span class="comment">//读取接收到得数据</span></div><div class="line">	socket.receive(packet);</div><div class="line">	<span class="comment">//把客户端发送的数据转换为字符串。</span></div><div class="line">	<span class="comment">//使用三个参数的String方法。参数一：数据包 参数二：起始位置 参数三：数据包长</span></div><div class="line">	String result = <span class="keyword">new</span> String(packet.getData(),packet.getOffset() ,packet.getLength());</div><div class="line">	&#125;<span class="keyword">catch</span>(SocketException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><font color="#FF7256">总结：</font></strong></p>
<p>使用UDP方式android端和服务器端接收可以看出，其实android端和服务器端的发送和接收大庭相径，只要端口号正确了，相互通信就没有问题，TCP使用的是流的方式发送，UDP是以包的形式发送。</p>
<p>最后附上七层模型图：</p>
<p><img src="http://storage1.imgchr.com/images/OSI.gif" alt="@OSI七层模型"></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/http-https/" rel="tag"># http/https</a>
          
            <a href="/tags/retrofit2/" rel="tag"># retrofit2</a>
          
            <a href="/tags/OkHttp3/" rel="tag"># OkHttp3</a>
          
            <a href="/tags/Socket/" rel="tag"># Socket</a>
          
            <a href="/tags/TCP/" rel="tag"># TCP</a>
          
            <a href="/tags/GET-POST/" rel="tag"># GET/POST</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/21/网络请求/" rel="next" title="网络请求">
                <i class="fa fa-chevron-left"></i> 网络请求
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/07/十批判书/" rel="prev" title="十批判书">
                十批判书 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="SOHUCS"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/photo-1-2.jpeg"
               alt="peanut" />
          <p class="site-author-name" itemprop="name">peanut</p>
           
              <p class="site-description motion-element" itemprop="description">天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣！</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/" target="_blank" title="jianshu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  jianshu
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/peanutDD" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、HTTP"><span class="nav-number">1.</span> <span class="nav-text">一、HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#协议版本："><span class="nav-number">1.1.</span> <span class="nav-text">协议版本：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP-0-9："><span class="nav-number">1.1.1.</span> <span class="nav-text">HTTP/0.9：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP-1-0："><span class="nav-number">1.1.2.</span> <span class="nav-text">HTTP/1.0：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#请求报文格式："><span class="nav-number">1.1.2.1.</span> <span class="nav-text">请求报文格式：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#响应报文格式："><span class="nav-number">1.1.2.2.</span> <span class="nav-text">响应报文格式：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Header"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">Header</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#通用首部字段（HTTP-1-1）"><span class="nav-number">1.1.2.4.</span> <span class="nav-text"> 通用首部字段（HTTP/1.1）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#请求首部字段"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">请求首部字段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#响应首部字段"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">响应首部字段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#实体首部字段"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">实体首部字段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#为-Cookie-服务的首部字段"><span class="nav-number">1.1.2.8.</span> <span class="nav-text">为 Cookie 服务的首部字段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#其他首部字段"><span class="nav-number">1.1.2.9.</span> <span class="nav-text">其他首部字段</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP-1-1："><span class="nav-number">1.1.3.</span> <span class="nav-text">HTTP/1.1：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#持久连接："><span class="nav-number">1.1.3.1.</span> <span class="nav-text">持久连接：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#管道机制："><span class="nav-number">1.1.3.2.</span> <span class="nav-text">管道机制：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#分块传输编码："><span class="nav-number">1.1.3.3.</span> <span class="nav-text">分块传输编码：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#其他功能："><span class="nav-number">1.1.3.4.</span> <span class="nav-text">其他功能：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Weakness："><span class="nav-number">1.1.3.5.</span> <span class="nav-text">Weakness：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SPDY协议："><span class="nav-number">1.1.4.</span> <span class="nav-text">SPDY协议：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP-2："><span class="nav-number">1.1.5.</span> <span class="nav-text">HTTP/2：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#二进制协议："><span class="nav-number">1.1.5.1.</span> <span class="nav-text">二进制协议：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#多工："><span class="nav-number">1.1.5.2.</span> <span class="nav-text">多工：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#数据流："><span class="nav-number">1.1.5.3.</span> <span class="nav-text">数据流：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#头信息压缩："><span class="nav-number">1.1.5.4.</span> <span class="nav-text">头信息压缩：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#服务器推送："><span class="nav-number">1.1.5.5.</span> <span class="nav-text">服务器推送：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、HTTPS"><span class="nav-number">2.</span> <span class="nav-text">二、HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-的安全通信机制"><span class="nav-number">2.1.</span> <span class="nav-text">HTTPS 的安全通信机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SL-和-TLS"><span class="nav-number">2.1.1.</span> <span class="nav-text">SL 和 TLS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SSL-速度"><span class="nav-number">2.1.2.</span> <span class="nav-text">SSL 速度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SSL-客户端认证"><span class="nav-number">2.1.3.</span> <span class="nav-text">SSL 客户端认证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、SOCKET"><span class="nav-number">3.</span> <span class="nav-text">三、SOCKET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#N层交换技术"><span class="nav-number">3.1.</span> <span class="nav-text">N层交换技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket通信简介"><span class="nav-number">3.2.</span> <span class="nav-text">Socket通信简介</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">peanut</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cytiSFA08';
      var conf = '233a465db3e4fe27659005b4347834ba';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

</body>
</html>
